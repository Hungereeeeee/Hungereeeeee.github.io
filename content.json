[{"title":"数据类型转换","date":"2017-02-28T11:10:21.000Z","path":"2017/02/28/数据类型转换/","text":"一直没太在意数据类型转换，所以今天记录一下所看到的数据类型转换的知识。 由于JavaScript是一种动态类型语言，变量没有类型限制，所以可以随时赋予任意值。而在某些情况下，变量就会自动进行类型转换例如：1&apos;5&apos;-&apos;2&apos;//3 虽然是字符串相减但是也会因为自动转换的原因得到数值 强制类型转换Number()函数可以将任意类型转换成数值 原始类型转换规则：原始类型的值主要是字符串、布尔值、undefined和null，它们都能被Number转成数值或NaN。其中空字符串转换为0 对象的转换规则简单规则是对象会转换为0 String()转换规则如下： 原始类型值的转换： 数值：转化为相应内存 字符串：转换后还是原值 布尔值：true转为”true”，false转换为”false” undefined：转为”undefined” null：转为”null” 对象转换规则：如果是对象，返回一个类型字符串，如果是数组，返回该数组的字符串形式 Boolean()转换规则相对简单：除了以下六个值的转换结果为false，其他全部为true123456undefinednull-00或+0NaN&apos;&apos; 接下来是重头戏，自动转换 自动转换遇到一下三种情况时，JavaScript会自动转换数据类型。1234567891011//1. 不同类型的数据相互运算1 + &apos;a&apos; //1a//2. 对非布尔值类型的数据求布尔值if(&apos;a&apos;)&#123; console.log(&apos;hello world&apos;)&#125;//hello world//3. 对非数值类型的数据使用一元运算符（即“+”和“-”）+&#123;a:&apos;hello&apos;&#125;//NaN-[1,2,3]//NaN 自动转换为布尔值当JavaScript遇到预期为布尔值的地方（if、三元运算符等），就会将非布尔值的参数转换为布尔值，系统自动调用Boolean()函数 自动转换为字符串当JavaScript遇到预期为字符串的地方，就会将非字符串的数据自动转为字符串。系统内部会自动调用String()函数。字符串的自动转换，只要发生在加法运算时。当一个值为字符串，另一个值为非字符串，则后者转为字符串123&apos;1&apos;+2 // &apos;12&apos;&apos;1&apos;+true // &apos;1true&apos;&apos;1&apos; + undefined //&apos;1undefined&apos; 所以要小心类似以下情况引起的问题JSBin 自动转换为数值当JavaScript遇到预期为数值的地方，就会将参数值自动转换为数值。系统内部会自动调用Number函数。除了加法运算符有可能把运算子转为字符串，其他运算符都会把运算子自动转成数值。12341+&apos;1&apos;//112-&apos;1&apos;//1&apos;1&apos; * [] //0&apos;abc&apos; - 1//NaN 一元预算福也会把运算子转成数值1234+&apos;abc&apos; // NaN-&apos;abc&apos; // NaN+true // 1-false // 0","tags":[]},{"title":"异步执行","date":"2017-02-27T13:42:17.000Z","path":"2017/02/27/异步执行/","text":"JS的异步执行每一个任务分成两段，第一段代码包含对外部数据的请求，第二段代码被写成一个回调函数，包含了对外部数据的处理。第一段代码执行完，不是立刻执行第二段代码，而是将程序的执行权交给第二个任务。等到外部数据返回了，再由系统通知执行第二段代码。所以程序的执行顺序与任务的排列顺序是不一致的异步的。 回调函数回调函数是异步编程最基本的方法 1234567function f1(callback) &#123; // f1 的代码 // f1 执行完成后，调用回调函数 callback();&#125;f1(f2); 回调函数的优点是简单、容易理解和部署，缺点是不利于代码的阅读和维护，各个部分之间高度耦合（Coupling），使得程序结构混乱、流程难以追踪（尤其是回调函数嵌套的情况），而且每个任务只能指定一个回调函数。 事件监听任务的执行不取决于代码的顺序，而取决于某个事件是否发生 123456function f1()&#123; setTimeout(function () &#123; // f1的任务代码 f1.trigger(&apos;done&apos;); &#125;, 1000);&#125; 发布订阅模式 异步操作流程一个异步代码1234function async(arg, callback) &#123; console.log(&apos;参数为 &apos; + arg +&apos; , 1秒后返回结果&apos;); setTimeout(function() &#123; callback(arg * 2); &#125;, 1000);&#125; 一个完成后的执行函数123function final(value) &#123; console.log(&apos;完成: &apos;, value);&#125; 串行执行我们可以编写一个流程控制函数，让它来控制异步任务，一个任务完成之后，再执行另一个，这就叫串行执行 12345678910111213var items = [ 1, 2, 3, 4, 5, 6 ];var results = [];function series(item) &#123; if(item) &#123; async( item, function(result) &#123; results.push(result); return series(items.shift()); &#125;); &#125; else &#123; return final(results); &#125;&#125;series(items.shift()); 上面代码中，函数series就是串行函数，它会依次执行异步任务，所有任务都完成后，才会执行final函数。items数组保存每一个异步任务的参数，results数组保存每一个异步任务的运行结果。 并行执行流程控制函数也可以是并行执行，即所有异步任务同时执行，等到全部完成以后，才执行final函数。 1234567891011var items = [1,2,3,4,5,6]var results=[];items.forEach(function(item)&#123; async(item,function(result)&#123; results.push(result); if(results.length == items.length)&#123; final(results) &#125; &#125;)&#125;) 上面代码中，forEach方法会同时发起6个异步任务，等到它们全部完成以后，才会执行final函数。 并行执行的好处是效率较高，比起串行执行一次只能执行一个任务，较为节约时间。但是问题在于如果并行的任务较多，很容易耗尽系统资源，拖慢运行速度。因此有了第三种流程控制方式。 并行和串行结合 1234567891011121314151617181920var items = [ 1, 2, 3, 4, 5, 6 ];var results = [];var running = 0;var limit = 2;function launcher() &#123; while(running &lt; limit &amp;&amp; items.length &gt; 0) &#123; var item = items.shift(); async(item, function(result) &#123; results.push(result); running--; if(items.length &gt; 0) &#123; launcher(); &#125; else if(running == 0) &#123; final(); &#125; &#125;); running++; &#125;&#125;launcher(); Promise是一个对象，起到代理作用，充当异步操作与回调函数之间的中介。它使得异步操作具备同步操作的接口，使得程序具备正常的同步运行的流程，回调函数不必再一层层嵌套。简单说，它的思想是，每一个异步任务立刻返回一个Promise对象，由于是立刻返回，所以可以采用同步操作的流程。这个Promises对象有一个then方法，允许指定回调函数，在异步任务完成后调用。1(new Promise(f1)).then(f2); Promise接口Promise三种状态：异步操作“未完成”（pending）异步操作“已完成”（resolved，又称fulfilled）异步操作“失败”（rejected） 异步操作成功，Promise对象传回一个值，状态变为resolved异步操作失败，Promise对象抛出一个错误，状态变为rejected .thenPromise对象使用then方法添加回调函数。then方法可以接受两个回调函数，第一个是异步操作成功时（变为resolved状态）时的回调函数，第二个是异步操作失败（变为rejected）时的回调函数（可以省略）。一旦状态改变，就调用相应的回调函数。 12345// po是一个Promise对象po.then( console.log, console.error) then方法可以链式使用 12345678po .then(step1) .then(step2) .then(step3) .then( console.log, console.error ); console.log只显示回调函数step3的返回值，而console.error可以显示步骤中的任意一个错误，也就是说前面步骤发生错误后面步骤都不会执行。这也就是说，Promises对象的错误有传递性 Promise对象的生成123456789var promise = new Promise(function(resolve, reject) &#123; // 异步操作的代码 if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;);","tags":[]},{"title":"块级作用域","date":"2017-02-14T02:01:00.000Z","path":"2017/02/14/块级作用域/","text":"在ES6之前，JavaScript没有块级作用域的概念。通常用匿名函数来模仿块级作用域。12(function()&#123;&#125;)(); 在一些情况下，我们要同时用闭包和匿名函数才能达到效果，例如：12345678910111213var list = document.getElementById(&quot;list&quot;);for (let i = 1; i &lt;= 5; i++) &#123; var item = document.createElement(&quot;LI&quot;); item.appendChild(document.createTextNode(&quot;Item &quot; + i)); item.onclick = function () &#123; return (function(j)&#123; console.log(&quot;Item &quot; + j + &quot; is clicked.&quot;); &#125;)(i) &#125;; list.appendChild(item);&#125; JSBin 而在ES6中引入了块级作用域概念。 通过var声明的变量没有块级作用域. 在语句块(block)里声明的变量作用域是其所在的函数或者 script 标签内, 你可以在语句块外面访问到它. 换句话说, 语句块不会生成一个新的作用域. 尽管单独的语句块是合法的语句, 但在JavaScript中你不会想使用单独的语句块,因为它们不像你想象的C或Java中的语句块那样处理事物. 例如:12345var x = 1;&#123; var x = 2;&#125;console.log(x); // 输出 2 只用使用let或const声明的变量是用块级作用域的。12345let x = 1;&#123; let x = 2;&#125;console.log(x); // 输出 1 现在则可以简化代码，避免闭包带来的问题123456789101112var list = document.getElementById(&quot;list&quot;);for (let i = 1; i &lt;= 5; i++) &#123; var item = document.createElement(&quot;LI&quot;); item.appendChild(document.createTextNode(&quot;Item &quot; + i)); let j = i; item.onclick = function (ev) &#123; console.log(&quot;Item &quot; + j + &quot; is clicked.&quot;); &#125;; list.appendChild(item);&#125; JSBin","tags":[]},{"title":"CSS3","date":"2017-01-11T16:00:00.000Z","path":"2017/01/12/CSS3/","text":"注：根据MDN显示，许多CSS3新增属性都是尚在实验中的功能，使用前请务必参考好浏览器兼容性Can I Use，添加所需前缀。使用 CSS3动画可以实现各种绚丽的效果，主要靠想象力。 渐变色都有什么方式？ 线性渐变12345678910background:linear-gradient(direction,color-stop1,....)background:linear-gradient(to end-direction,color-stop1,....)//对角background:linear-gradient(to end-level end-vertical,color-stop1,....)//角度background:linear-gradient(angle,color-stop1 10% ,....)//透明度 第二个点默认为50%位置background:linear-gradient(angle,rgba(255,0,0,0),rgba(255,0,0,.5),rgba(255,0,0,1))//重复线性渐变background:repeating-linear-gradient(90deg,red 0%,blue 20%); 由于在不同浏览器兼容问题中direction的写法可能不同，所以推荐使用角度写法，下图为不同角度对应的线性方向 径向渐变从起点到终点颜色从内到外进行圆形渐变（从中间向外拉）位置是对角线1234567background:radial-gradient(center,shape size,color-stop,...)//设置形状 cicle ellipse(默认形状)background:radial-gradient(shape,color-stop1,...)//尺寸大小关键字 closest-side:最近边 farthest-side:最远边 closest-corner:最近角 farthest-corner:最远角background:radial-gradient:(size,color-stop,...)//重复渐变background:repeating-radial-gradient(size,color-stop) 什么是transform属性？CSS中transform 属性允许你修改CSS可视化模型的坐标空间。通过transform，可以让元素进行移动（translate）、旋转（rotate）、缩放（scale）、倾斜（skew）。 2D转换 12345678//角度transform:rotate();//平移transform:translate();//缩放tranform:scale(.5);//斜切transform：skew(0deg); 3D转换 12345678//角度transform:rotate3d();//平移transform:translate3d();//缩放tranform:scale3d();//改变转换元素的位置transform-origin:x-axis y-axis z-axis; 什么是Transition属性？过渡属性（Transition）：允许CSS的属性值在一定的时间区间内平滑过渡。transition-property:none|all|property：检索或设置对象中参与过渡的属性 可写可不写transition-duration:time：检索或设置对象过渡的持续时间 默认值是0tansition-timing-function：检索或设置对象中过渡的动画类型transition-delay:time：检索或设置对象延迟过渡时间transition:property duration timing-function delay 什么是关键帧？@keyframes 让开发者通过指定动画中特定时间点必须展现的关键帧样式（或者说停留点）来控制CSS动画的中间环节。这让开发者能够控制动画中的更多细节而不是全部让浏览器自动处理。写法：12345@keyframes animationname&#123; keyframes-selector&#123; css-styles; &#125;&#125; 为了让一个关键帧列表有效，它必须至少包含了对0%（或from）和100%（或to）即动画的开头帧和结束帧的定义。 如果都没有进行定义，那么整个@keyframes 是无效的，不能使用。关键帧MDN 动画属性 animation-name:keyframename|none：检索或设置对象所应用的动画名称 keyframename:指定要绑定到选择器的关键帧的名称 none:指定有没有动画（可用于覆盖从级联的动画） animation-duration:time：检索或设置动画的持续时间 time：指定动画持续时间 animation-timing-function：检索或设置对象动画的过渡类型 animation-delay：检索或设置对象动画的延迟时间 animation-iteration-count:infinite|number：检索或设置动画的循环次数 infinite：无限次 animation-direction:normal|reverse|alternate|alternate-reverse|initial|inherit：检索或设置对象动画在循环中是否反向运动 normal：正常方向 reverse：反方向运行 alternate：动画先正常运行再反方向运行，并持续交替运行 alternate-reverse：动画先反运行再正方向运行，并持续交替运行 animation-fill-mode:none|forwards|backwards|both|initial|inherit：动画在不播放时（当动画完成或者当动画有延迟未开始播放时，要应用到元素的样式） animation-play-state:paused|running：指定动画是否正在运行或已暂停 animation:name duration timing-function delay iteration-count direction fill-mode play-state 所有属性的基本写法：JSbin","tags":[]},{"title":"HTML5","date":"2017-01-08T16:00:00.000Z","path":"2017/01/09/HTML5/","text":"HTML5是什么？有哪些新特性？有哪些新增标签？如何让低版本的 IE 支持 HTML5新标签HTML5是HTML的第五次重大修改，设计目的是为了在移动设备上支持更多媒体。新特性： 语义特性 本地存储特性（localStorage Indexed DB） 设备兼容特性 （Geolocation功能） 连接特性（实时特性，webSockets） 网页多媒体特性（Audio Vedio Canvas SVG） 性能与集成特性（XMLHttpRequest2等技术） CSS3特性 新增标签：&lt;header&gt; &lt;article&gt; &lt;nav&gt; &lt;footer&gt; &lt;section&gt; &lt;aside&gt; &lt;dialog&gt; &lt;audio&gt; &lt;vedio&gt;让低版本的 IE 支持 HTML5新标签: 这段代码仅会在IE浏览器下运行，还有一点需要注意，在页面中调用html5.js文件必须添加在页面的head元素内，因为IE浏览器必须在元素解析前知道这个元素，所以这个js文件不能在页面底部调用. 1&lt;!--[if IE]&gt;&lt;script src=”http://html5shiv.googlecode.com/svn/trunk/html5.js”&gt;&lt;/script&gt; &lt;![endif]--&gt; 在hmtl 加入（推荐）除了在网页中调用包含以上代码的js文件来让IE浏览器支持HTML5元素以外，你也可以以下面这种方式把代码直接添加到网页中。 12345&lt;!--[if lt IE 9]&gt;&lt;script&gt;(function()&#123;if(!/*@cc_on!@*/0)return;var e = “abbr,article,aside,audio,canvas,datalist,details,dialog,eventsource,figure,footer,header,hgroup,mark,menu,meter,nav,output,progress,section,time,video”.split(’,&apos;),i=e.length;while(i–)&#123;document.createElement(e[i])&#125;&#125;)()&lt;/script&gt;&lt;![endif]--&gt; input有那些新增类型？input属性多数只针对手机端有特殊效果，并且多数有兼容问题，在使用之前请在Can I Use查明兼容性 email：输入邮箱规范地址 url：只针对苹果手机，输入的链接要满足链接的规范 tel number：只能输入能参与运算的数字，PC端和手机端都有用 Date Pickers Input类型：iphone手机和PC端有效 其他类型 浏览器本地存储中 cookie 和 localStorage 有什么区别？ localStorage 如何存储删除数据。 特性 Cookie localStorage 数据的生命期 可设置失效时间，默认是关闭浏览器后失效 除非被清除，否则永久保存 存放数据大小 4K左右 一般为5MB 与服务器端通信 每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题 仅在客户端（即浏览器）中保存，不参与和服务器的通信 易用性 需要程序员自己封装，源生的Cookie接口不友好 源生接口可以接受，亦可再次封装来对Object和Array有更好的支持 localStorage.setItem()：接受一个键值对作为参数，将会把键名添加到存储中，如果键名以存在，则更新其对应的值。localStorage.removeItem()：接受一个键名作为参数，会把该键名从存储中移除。localStorage.clear()：不接受参数，只是简单地清空域名对应的整个存储对象。","tags":[]},{"title":"响应式布局","date":"2017-01-04T16:00:00.000Z","path":"2017/01/05/响应式布局/","text":"什么是响应式布局？响应式布局是Ethan Marcotte在2010年5月份提出的一个概念，简而言之，就是一个网站能够兼容多个终端——而不是为每个终端做一个特定的版本。这个概念是为解决移动互联网浏览而诞生的。 响应式布局可以为不同终端的用户提供更加舒适的界面和更好的用户体验，而且随着目前大屏幕移动设备的普及，用“大势所趋”来形容也不为过。 响应式布局的优缺点？ 优点： 面对不同分辨率设备灵活性强 能够快捷解决多设备显示适应问题 缺点 兼容各种设备工作量大，效率低下 代码累赘，会出现隐藏无用的元素，加载时间加长 其实这是一种折衷性质的设计解决方案，多方面因素影响而达不到最佳效果 一定程度上改变了网站原有的布局结构，会出现用户混淆的情况 响应式布局的设计在面对不同的尺寸的设备时怎样鉴别呢？我们需要用到CSS3的媒介查询技术（Media Query） ####什么是媒体查询？媒体查询包含一个可选的媒体类型和零或多个表达式来限制使用媒体特性的样式表范围,例如width,height,color.CSS3中的Media queries让内容的呈现可以只针对特定范围的输出设备而不必去改变内容本身.媒体查询级别较高，不在html之下，所以用相对单位对其进行设置都是相对于浏览器设置的。 基本写法：1234@media all and(min-width:800px) and (orientation:landscape)&#123; ...&#125; 媒体查询的逻辑操作符and not only , 就是链接表达式and：与 全部匹配,：或 任意条件匹配一个not：非only：防止老旧的浏览器，不支持带媒体属性的查询，而应用到给定的样式 媒体属性简介 width：视口宽度 height：视口高度 device-width：渲染表面的宽度，就是设备屏幕的宽度 device-height：渲染表面的高度，就是设备屏幕的高度 orientation：检查设备处于横向还是纵向 aspect-ratio：基于视口宽度和高度的宽高比。 width/height 如：16/9,4/3 device-aspect-ratio：渲染表面的宽度，就是设备屏幕的宽度 color：每种颜色的位数bits 如：min-color：16位 8位 resolution：检测屏幕或打印机的分辨率以上属性都可以添加min-或max-前缀 视口viewport什么是视口？视口是与设备相关的一个矩形区域，坐标单位是与设备相关的。为了小屏幕（手机）的显示，将视口分为以下状态以达到显示目的 布局视口(layout viewport)：用一个虚拟的960px宽度或更高 先把网页布局出来 宽度不变 可视视口(visual viewport)：在手机呈现出来的区域的宽度 会通过用户的缩放等操作进行改变 理想视口(ideal viewport)：布局视口在一个设备上的最佳尺寸 为构建手机浏览器优化的页面而添加的 例如百度首页对视口的设置1234&lt;meta name=&apos;viewport&apos; content=&apos;width=device-width,//使用理想视口minimum-scale=1.0,//最小縮放比例maximum-scale=1.0,//最大缩放比例user-scalable=no&apos;/&gt;//禁用用户缩放 响应式图片在网站设计中，针对于手机端的设计使用大屏幕的图片会造成流量的浪费以及加载的缓慢，这显然有着不好的用户体验，针对这种情况，而提出了响应式图片的概念和解决方法 通过js或服务端解决：通过js判断屏幕大小，在不同分辨率的情况下加载不同的屏幕 srcset配合sizes123&lt;img class=&apos;image&apos; src=&apos;img/480.png&apos; srcset=&apos;img/480.png 470w, img/800.png 800w, img/1600.png 1600w&apos; sizes=&apos;50vw&apos;&gt; 详细参考：响应式图片srcset全新释义 picture标签1234567&lt;picture&gt; &lt;source media=&quot;min-width:36em&quot; srcset=&quot;img/pic-s.jpg 768w&quot;/&gt; &lt;source srcset=&quot;img/pic.jpg 1800w&quot;/&gt; ![](img/pic.jpg)&lt;/picture&gt; 这是一个尚在开发中的功能，详细请查看MDN,针对该标签兼容问题可用该插件解决picturefill svg矢量图 响应式网站的设计原则 内容流动：随着屏幕尺寸变小，内容将会占据更多的垂直空间，而下方的内容就会被接着往下推，这就是所谓的流动。 使用相对单位：画布大小可以是desktop、mobile或是它们之间的任何尺寸。像素密度也可以有所不同，所以我们需要灵活的、在各种屏幕上都可以使用的单位。 断点：不要根据某一特定手机种类进行断点设置，而是根据大体的屏幕分类像素分类进行设置。如：0-480为小屏幕 481-800为中屏幕等 最大值或最小值：有时候，如果内容占据了屏幕的整个宽度是很好的，比如在移动设备上。但是如果是在电视屏幕上，相同的内容，占据了你的屏幕整个的宽度，通常就意义不大了。这就是Min/Max值发挥作用的时候了。 本文目的旨在记录学习当中所遇到的重要知识点，所以难免疏漏或者错误，欢迎指正讨论","tags":[]},{"title":"Canvas绘图","date":"2016-12-30T16:00:00.000Z","path":"2016/12/31/Canvas绘图/","text":"什么是Canvas？&lt;canvas&gt; 是 HTML5 新增的元素，可使用JavaScript脚本来绘制图形。例如：画图，合成照片，创建动画甚至实时视频处理与渲染。 开始之前使用 &lt;canvas&gt;元素不是非常难但你需要一些基本的HTML和JavaScript知识。 元素不被一些老的浏览器所支持，但是所有的主流浏览器的新近版本都支持。Canvas 的默认大小为300像素×150像素（宽×高，像素的单位是px）。但是，可以使用HTML的高度和宽度属性来自定义Canvas 的尺寸。为了在 Canvas 上绘制图形，我们使用一个JavaScript上下文对象，它能动态创建图像（ creates graphics on the fly）。 注意事项虽然可以通过CSS来控制&lt;canvas&gt;大小。但在渲染过程中&lt;canvas&gt;元素中的内容会根据情况缩放来适应需要的大小。如果您发现&lt;canvas&gt;元素中展示的内容变形，您可以通过内联方式或通过JavaScript进行宽高相关设置，而不要使用CSS。例：12345&lt;canvas id=&quot;canvas&quot; width=&quot;300&quot; height=&quot;300&quot;&gt; Sorry, your browser doesn&apos;t support the &lt;canvas&gt;element.&lt;/canvas&gt; 下面开始canvas绘图 初始化12var canvas=document.getElementById(&apos;canvas&apos;)var context=canvas.getContext(&apos;2d&apos;) 绘图为状态绘图，应该先进行状态设置，再选用函数进行具体绘制因为canvas为状态绘图，则会导致在绘图时之前的状态设置也会同时进行设置，造成覆盖 beginPath()和closePath()beginPath()：开始一条路径，或重置当前的路径。closePath()：如果画布的子路径是打开的，closePath() 通过添加一条线条连接当前点和子路径起始点来关闭它。 线条属性 lineCap ：用于设置线条两端形状 只能用于线段的开始处和结尾处，不能用于连接处 butt(default) round square lineJoin：线条相交时的形态 miter(default) miterLimit:内角和外角的最大值如果超过就用bevel方式显示 bevel round 绘制线条线条属性多线条绘制 填充样式 fillStyle渐变色填充 线性渐变色12345//Step1var grd=context.createLinearGradient(xstart,ystart,xend,yend);//Step2//stop:浮点值 渐变色位置grd.addColorStop(stop,color); 线性渐变 径向渐变12var grd=context.createRadialGradient(x0,y0,r0,x1,y1,r1);grd.addColorStop() 径向渐变 createPattern1234567createPattern(img,repeat-style)repeat-style:no-repeat :repeat-x repeat=y repeatcreatePattern(canvas,repeat-style)createPattern(video,repeat-style) 曲线绘制arc12345context.arc( centerx,centery,radius, startingAngle,endingAngle, anticlockwise=false) centerx,centery：圆心坐标radius：半径startingAngle，endingAngle：从哪一个弧度值为始，结束于哪一个弧度值anticlockwise：顺时针（false）绘制 逆时针时针绘制圆形绘制 arcTo将当前的点坐标（moveTo等）传入x1,y1,x2,y2后将会形成一个由两个线段组成的折线，将从x0,y0开始绘制,x1,y1,x2,y2告诉圆弧用那两条线当作切线，但是切点不一定在这两条线段上12context.moveTo(x0,y0);context.arcTo(x1,y1,x2,y2,radius); arcTo 贝塞尔二次曲线12context.moveTo(x0,y0);context.quadraticCurveTo(x1,y1,x2,y2); 贝塞尔曲线 贝塞尔三次曲线1234context.moveTo(x0,y0);context.bezierCurveTo( x1,y1,x2,y2,x3,y3) 贝塞尔三次曲线 文字渲染12context.font=&apos;bold 40px Arial&apos;context.fillText(string,x,y,[maxlen]) 默认值：20px sans-serifcontext.font 和css中font相同文字渲染 文本对齐1234//水平context.textAlign=&apos;left/center/right&apos;//垂直context.textBaseline=&apos;top/middle/bottom/alphabetic(Default基于拉丁语的基准线)/ideographic(基于中文、日文的基准线)/hanging(基于印度语的基准线)&apos; 文本的度量1context.measureText(string).width 阴影123456context.shadowColor//阴影偏移量context.shadowOffsetXcontext.shadowOffsetY//阴影模糊值context.shadowBlur 阴影 全局12345//全局透明度context.globalAlpha//绘制的图像重叠时产生的效果context.globalCompositeOperation=&apos;source-over(Default)/destination-over(先绘制的图形在上面)&apos; 剪辑区域1context.clip() clip 非零环绕原则 参考资料：非零环绕原则圆环绘制 图形变换 位移：translate(x,y) 旋转：rotate(deg) 缩放：scale(sx,sy) 不仅仅放大图像大小，对坐标线条宽度等也会缩放图形变换是叠加的canvas.save()/.restore()：保存/返回图形状态transformationtarnsform context原型1CanvasRenderingContext2d 图形库1图形库2图形库3 综合应用星星绘制月亮绘制星空绘制运动的小球倒计时 本文旨在记录在初步学习canvas当中用到的一些方法，个人认为canvas主要需要对图形计算的熟悉，绘制图形之前需要先计算好绘制的路径，例如每个角的角度等等，详细学习路径请查看Canvas教程 文中代码地址：GitHub","tags":[]},{"title":"fullPage","date":"2016-12-28T16:00:00.000Z","path":"2016/12/29/fullPage/","text":"什么是fullPage?fullPage.js 是一个基于 jQuery 的插件，它能够很方便、很轻松的制作出全屏网站，主要功能有： 支持鼠标滚动 支持前进后退和键盘控制 多个回调函数 支持手机、平板触摸事件 支持 CSS3 动画 支持窗口缩放 窗口缩放时自动调整 可设置滚动宽度、背景颜色、滚动速度、循环选项、回调、文本对齐方式等等 fullPage的页面结构和配置项123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;fullpage&lt;/title&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/fullPage.js/2.9.2/jquery.fullPage.css&quot;&gt; &lt;style&gt; .slide&#123; text-align: center; &#125; #fullpageMenu&#123; position: fixed; top: 0; z-index: 999; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul id=&quot;fullpageMenu&quot;&gt; &lt;li data-menuanchor=&apos;page1&apos; class=&quot;active&quot;&gt;&lt;a href=&quot;#page1&quot;&gt;1 section&lt;/a&gt;&lt;/li&gt; &lt;li data-menuanchor=&apos;page2&apos;&gt;&lt;a href=&quot;#page2&quot;&gt;2 section&lt;/a&gt;&lt;/li&gt; &lt;li data-menuanchor=&apos;page3&apos;&gt;&lt;a href=&quot;#page3&quot;&gt;3 section&lt;/a&gt;&lt;/li&gt; &lt;li data-menuanchor=&apos;page4&apos;&gt;&lt;a href=&quot;#page4&quot;&gt;4 section&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;!-- &lt;div id=&quot;header&quot;&gt;header&lt;/div&gt; --&gt; &lt;div id=&quot;fullpage&quot;&gt; &lt;div class=&quot;section&quot;&gt;这是第一个页面&lt;/div&gt; &lt;div class=&quot;section&quot;&gt; &lt;div class=&quot;slide&quot;&gt;Slide 1&lt;/div&gt; &lt;div class=&quot;slide&quot;&gt;Slide 2&lt;/div&gt; &lt;div class=&quot;slide&quot;&gt;Slide 3&lt;/div&gt; &lt;div class=&quot;slide&quot;&gt;Slide 4&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;section&quot;&gt;这是第三个页面&lt;/div&gt; &lt;!--active类定位到当前页面--&gt; &lt;div class=&quot;section&quot;&gt;这是第四个页面&lt;/div&gt; &lt;/div&gt; &lt;script src=&apos;https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.js&apos;&gt;&lt;/script&gt; &lt;script src=&apos;https://cdnjs.cloudflare.com/ajax/libs/fullPage.js/2.9.2/jquery.fullPage.js&apos;&gt;&lt;/script&gt; &lt;script&gt; $(document).ready(function() &#123; $(&apos;#fullpage&apos;).fullpage(&#123; //设置background-color属性 sectionsColor:[&apos;blue&apos;,&apos;green&apos;,&apos;orange&apos;,&apos;red&apos;], //定义是否通过箭头来控制slide幻灯片，默认为true.在移动设备上可一个通过滑动来操作幻灯片 controlArrows:true, //每一页的内容是否垂直居中 verticalCentered:true, //字体是否随着页面缩放而缩放，默认值为false resize:false, //滚动速度,默认为700 单位ms scrollingSpeed:700, /*、定义锚链接，默认值为[]。有了锚链接用户可以快速打开定位到某一页面。定义锚链接的时候，值不要和页面中任意的id或name相同，尤其在IE浏览器下。而且定义时不需要加#*/ anchors:[&apos;page1&apos;,&apos;page2&apos;,&apos;page3&apos;,&apos;page4&apos;], /*是否锁定锚链接，默认为false。如果设置为true，那么定义的锚链接，也就是anchors属性则没有效果*/ lockAnchors:false, /*滚动到最顶部后是否连续滚动到底部，默认为false*/ loopTop:false, /*滚动到底部后是否连续滚动回顶部，默认为false*/ loopBottom:false, /*横向slider幻灯片是否循环滚动，默认为true*/ loopHorizontal:true, /*是否使用插件的滚动方式，默认为true，如果选择false，则会出现浏览器自带的滚动跳，将不会暗夜滚动，而是按照滚动条的默认行为滚动*/ autoScrolling:true, /*是否包含过冬天，默认为false，如果设置为true，则浏览器自带的滚动条出现，页面还是按页滚动，但是滚动条的默认行为页有效*/ scrollBar:false, /*设置每一个section顶部和底部的padding，默认都为0。一般如果我们需要在顶部或底部的设置菜单、导航、元素等，可以使用这两个配置项。*/ paddingTop:&apos;0px&apos;, paddingBottom:0, /*固定的元素默认为null、需要配置一个jquery选择器。在页面滚动的时候，fixedElements设置的元素固定不动*/ fixedElements:&apos;#header&apos;, /*是否可以使用键盘方向键导航，默认为true*/ keyboardScrolling:true, /*在移动设备中滑动页面的敏感性，默认为5，是按百分比来衡量，最高为100，越大则越难滑动。*/ touchSensitivity:5, /*continuousVertical是否循环滚动，默认为false。如果设置为true，则页面会循环滚动，而不像loopTop或loopBottom那样出现跳动，注意这个属性和loopTop/loopBottom不兼容，不要同时设置*/ /*锚链接是否可以控制滚动动画，默认为true。如果为false则没有动画效果*/ animateAnchor:true, /*是否记录历史，默认为true，可以记录页面滚动的历史，通过浏览器的前进后退控制导航。注意如果设置了autoScrolling:false ,那么之歌配置也将被关闭，即设置为false*/ recordHistory:true, /*绑定彩蛋，设定的相关属性与anchors的值相对应后，彩蛋可以控制滚动，默认为false。可以设置为菜单的jquery选择器*/ menu:&apos;#fullpageMenu&apos;, /*是否显示导航，默认为false。如果设置为true，会显示小圆点，作为导航*/ navigation:true, /*导航小圆点位置，可以设置为left或者right*/ navigationPosition:&apos;right&apos;, /*navigationTooltips:导航小圆点的tooltips设置，默认为[],注意按照顺序设置*/ navigationTooltips:[&apos;page1&apos;,&apos;page2&apos;,&apos;page3&apos;,&apos;page4&apos;], /*是否显示当前页面的导航的tooltip信息，默认为false*/ showActiveTooltip:true, /*是否显示横向幻灯片的导航，默认为false*/ slidesNavigation:false, /*横向幻灯片导航的位置，默认为bottom，可以设置为top或bottom*/ slidesNavPosition:&apos;bottom&apos; /*scrollOverflow：内容超过满屏后是否显示滚动条，默认为false。如果设置为true，则会显示滚动条，如果要滚动查看内容，还需要jquery.slimscroll插件的配合。slimscroll插件主要用于模拟传统的浏览器滚动条*/ /*sectionSelector：section的选择器，默认为.section*/ /*slideSelector：slide的选择器，默认为.slides*/ &#125;); &#125;); /* 方法：调用方法均为 $.fn.fullpage.xxx() 1. moveSectionUp()/moveSectionDown()：向上或向下滚动一页 2. moveTo(section，slides)：滚动到第几页，第几个幻灯片，注意，页面是从1开始，而幻灯片是从0开始。 3. silentMoveTo(section,slide)：和moveTo一样，但是没有动画效果。 4. moveSlideRight()/moveSlideLeft()：幻灯片向右/左滚动 5. setAutoScrolling(boolean)：动态设置autoScrolling 6. setLockAnchors：动态设置lockAnchors 7. setRecordHistory(boolean)：动态设置recordHistory 8. setScrollingSpeed(milliseconds)：动态设置scrollingSpeed 9. setAllowScrolling(bollean,[directions])：添加或删除鼠标滚轮/滑动控制，第一个参数true为启用，false 为禁用，后面的参数为方向，取值包含all,up,down,left,right,可以使用多个，逗号分割 10. destroy(type)：销毁fullpage特效，type可以不写，或者使用all，不写type，fullpage给页面添加的样式和html元素还在，如果使用 all，则样式、html等全部销毁，页面恢复和不使用fullpage相同的效果 11. reBeuild()：重新更新页面和尺寸，用于通果ajax请求后改变了页面结构之后，重建效果。 Lazy Loading &lt;img data-src=&apos;img.png&apos;&gt; &lt;video&gt; &lt;source data-src=&apos;video.webm&apos; type=&apos;video/webm&apos;/&gt; &lt;video&gt; 回调 * afterLoad(anchorLink,index) 1. 滚动到某一section，且滚动结束后，会触发一次此回调函数，函数接收anchorLink和index两个参数，anchorLink时锚链接的名称，index是序号，从1开始计算。 2. 我们可以根据anchorLink和index参数值的判断，触发相应的事件 * onLeave(index,nextIndex,direction) 1. 在我们离开一个section时，会触发一次此回调函数，接收index/nextIndex/和direction 3个参数 I. index是离开的页面的序号，从1开始计算。 II. nextIndex是滚动的目标页面的序号，从1开始计算 III. direction判断往上滚动还是往下滚动，值是up或down 2. 通过return false 可以取消滚动 * afterRender() 页面结构生成后的回调函数，或者说是页面初始化完成后的回调函数 * afterResize() 浏览器窗口尺寸改变后的回调函数 * afterSlideLoad(anchorLink,index,slideAnchor,slideIndex) 滚动到某一幻灯片后的回调函数，与afterLoad类似 * onSlideLeave(anchorLink,index,slideIndex,direction,nextSlideIndex) 在我们离开一个slide时，会触发一次此回调函数，与onLeave类似 */ &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","tags":[]},{"title":"常见设计模式","date":"2016-11-06T16:00:00.000Z","path":"2016/11/07/常见设计模式/","text":"问答写出构造函数模式、混合模式、模块模式、工厂模式、单例模式、发布订阅模式的范例。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124////////////构造函数模式function Person(name,age)&#123; this.name=name; this.age=age;&#125;Person.prototype.sayName()=function()&#123; console.log(this.name)&#125;var people=new Person(&apos;人&apos;，22)/////////混合模式function Person(name,age)&#123; this.name=name; this.age=age;&#125;Person.prototype.sayName()=function()&#123; console.log(this.name)&#125;function Student(name,age,score)&#123; Person.call(this,name,age); this.score=score;&#125;function create(Obj)&#123; functino F()&#123;&#125; F.prototype=Obj.prototype; return new F();&#125;Student.prototype=create(Person);Student.prototype.sayScore=function()&#123; console.log(this.score)&#125;////////////模块模式var Person=(function()&#123; var name=&apos;hunger&apos; return&#123; changeName:function(newName)&#123; name=newName; &#125; sayName:function()&#123; console.log(name) &#125; &#125;&#125;)()/////////////工厂模式function createPerson(opts)&#123; var person=function()&#123; name:opts.name||&apos;ren&apos; &#125; person.sayName=function()&#123; console.log(this.name) &#125; return new person&#125;//////////////////单例模式var Car = (function()&#123; var instance; function init() &#123; //私有的变量和函数 var speed = 0; return &#123; //定义公共的属性和方法 getSpeed: function()&#123; return speed; &#125;, setSpeed: function( s )&#123; speed = s; &#125; &#125;; &#125; return &#123; getInstance: function() &#123; if (!instance) &#123; instance = init(); &#125; return instance; &#125; &#125;;&#125;());/////////////////发布订阅模式var EventCenter=(function()&#123; var events=&#123;&#125;; function on(evt,handler)&#123; events[evt]=events[evt]||[]; events[evt].push(&#123; handler:handler &#125;) &#125; function fire(evt,args)&#123; if (!events[evt]) &#123; return; &#125; for(var i=0;i&lt;events[evt].length;i++)&#123; events[evt][i].handler(args); &#125; &#125; return &#123; on:on, fire:fire &#125;&#125;)()//////////单例模式范例var Car = (function()&#123; var instance; function init() &#123; //私有的变量和函数 var speed = 0; return &#123; //定义公共的属性和方法 getSpeed: function()&#123; return speed; &#125;, setSpeed: function( s )&#123; speed = s; &#125; &#125;; &#125; return &#123; getInstance: function() &#123; if (!instance) &#123; instance = init(); &#125; return instance; &#125; &#125;;&#125;()); 使用发布订阅模式写一个事件管理器，可以实现如下方式调用12345EventManager.on(&apos;text:change&apos;, function(val)&#123; console.log(&apos;text:change... now val is &apos; + val);&#125;);EventManager.fire(&apos;text:change&apos;, &apos;饥人谷&apos;);EventManager.off(&apos;text:changer&apos;); 1234567891011121314151617181920212223var EventManager=(function()&#123; var events=&#123;&#125;; function on(evt,handler)&#123; events[evt]=events[evt]||[]; events[evt].push(handler); &#125; function fire(evt)&#123; if(!events[evt])&#123; return; &#125; for(var i=0;i&lt;events[evt].length;i++)&#123; events[evt][i]([].slice.call(arguments,1)); &#125; &#125; function off(evt)&#123; delete events[evt]; &#125; return&#123; on:on, fire:fire, off:off &#125;;&#125;)(); 代码 写一个函数createTimer，用于创建计时器，创建的计时器可分别进行计时「新增」。ps: 1. 计时器内部写法参考前面的任务中Runtime的写法; 2. 体会工厂模式的用法1234567891011121314151617function createTimer()&#123; //todo..&#125;var timer1 = createTimer();var timer2 = createTimer();timer1.start();for(var i=0;i&lt;100;i++)&#123; console.log(i);&#125;timer2.start();for(var i=0;i&lt;100;i++)&#123; console.log(i);&#125;timer1.end();timer2.end();console.log(timer1.get());console.log(timer2.get()); 12345678910111213141516function createTimer()&#123; function Timer()&#123; this.start; this.end; &#125; Timer.prototype.start=function()&#123; this.start=Date.now(); &#125; Timer.prototype.end=function()&#123; this.end=Date.now(); &#125; Timer.prototype.get=function()&#123; console.log(this.end-this.start); &#125; return new Timer;&#125; 封装一个曝光加载组件，能实现如下方式调用123456789//$target 是 jquery 对象// 当窗口滚动时，如果$target 出现在可见区域，执行回调函数里面的代码，且在回调函数内，$(this)代表$targetExpouse.bind($target, function()&#123; console.log($(this)); // $target&#125;);// 当窗口滚动时，如果$target 出现在可见区域，执行回调函数里面的代码，且在回调函数内，$(this)代表$target。 仅执行一次回调函数，下次$target 曝光不再执行Expourse.one($target, function()&#123; console.log($(this)); // $target&#125;) 在线预览 封装一个 轮播插件，分别使用对象方式和 jquery插件方式来调用123456789// 要求：html 里有多个carousel，当调用时启动全部的 carousel//方式1//通过插件的方式启动所有轮播$(&apos;.carousel&apos;).carousel();//方式2//通过创建对象的方式启动所有轮播$(&apos;.carousel&apos;).each(function()&#123; new Carousel($(this));&#125;); jQuery插件方式对象方式","tags":[]},{"title":"requireJS、r.js","date":"2016-11-01T16:00:00.000Z","path":"2016/11/02/requireJS、r-js/","text":"如下requirejs配置中, baseUrl 有什么作用？以什么作为基准? paths 的作用和用法是什么?123456requirejs.config(&#123; baseUrl: &quot;src/js&quot;, paths: &#123; &apos;jquery&apos;: &apos;lib/bower_components/jquery/dist/jquery.min&apos; &#125;&#125;); baseUrl定义了根路径，当多个js文件放入一个文件夹中，再调用不同的模块的时候就可以忽略跟路径，以html文件所在目录为基准；paths指相对路径，如果有特殊的模块需要调用而路径名很长就可以当度将其路径写出来 如下 r.js 的打包配置中 baseUrl 是什么? name 是什么12345678(&#123; baseUrl: &quot;./src/js&quot;, paths: &#123; &apos;jquery&apos;: &apos;lib/bower_components/jquery/dist/jquery.min&apos; &#125;, name: &quot;main&quot;, out: &quot;dist/js/merge.js&quot;&#125;) baseUrl是指相对于require.js中的baseUrl的路径；name指入口模块名字；out为输出路径在线预览","tags":[]},{"title":"CMD、AMD、CommonJS规范","date":"2016-10-10T16:00:00.000Z","path":"2016/10/11/CMD、AMD、CommonJS规范/","text":"为什么要使用模块化？最主要的目的： 解决命名冲突 依赖管理 其他价值： 提高代码可读性 代码解耦，提高复用性 CMD、AMD、CommonJS 规范分别指什么？有哪些应用模块的规范：定义一个统一的前提，大家必须以同样的方式编写模块。 CommonJS：CommonJS是服务器端模块的规范。 在一个模块中，存在一个自由的变量require，他是一个函数 这个require函数接受一个模块标识符 require返回外部模块所输出的API 如果出现依赖闭环，那么外部模块在被他的传递一台所require的时候可能并没有执行完成；在这种情况下，require返回的对象必须至少包含此外部模块在调用require函数之前就已经准备完毕输出 如果请求的模块不能返回，那么require必须抛出一个错误 在一个模块中，会存在一个名为exports的自由变量，它是一个对象，模块可以在执行的时候把自身的API加入其中 模块必须使用exports对象做唯一表示 CMD：是SeaJS推广过程中诞生的，在CMD规范中，一个模块就是一个文件，代码的书写格式如下 1define(factory) AMD：AMD（异步模块定义）指定一种机智，在该机制下模块和依赖可以异步加载。这对浏览器端尤其适用。 1define(id?,dependencies?,factory); id:定义中模块的名字，可选：如果没提供该参数，模块的名字应该默认为模块加载器请求的指定的脚本的名字。 dependencies：是一个当前模块依赖的，已被模块定义的模块标识的数组字面量。依赖参数是可选的。如果忽略次参数它应该默认为[“require”, “exports”, “module”]。然而，如果工厂方法的长度属性小于3，加载器会选择以函数的长度属性指定的参数个数调用工厂方法。 工厂方法，模块初始化要执行的函数或对象。如果为函数，他应该只被执行一次。如果是对象，此对象应该为模块的输出值。示例：1234define(&apos;modal&apos;, [&apos;jQuery&apos;, &apos;dialog&apos;], function($, Dialog)&#123; $(&apos;.modal&apos;).show(); Dialog.open();&#125;);","tags":[]},{"title":"继承","date":"2016-10-08T16:00:00.000Z","path":"2016/10/09/继承/","text":"继承有什么作用? 得到一个类的属性 得到一个类的方法 有几种常见创建对象的方式? 举例说明? 直接赋值var obj={}; 工厂模式 12345678910function createCake(name)&#123; var obj=&#123; name:name, sayName:function()&#123; console.log(&apos;我是:&apos;+name) &#125; &#125; return obj;&#125;var cake1= createCake(&apos;草莓蛋糕&apos;) 缺点是无法得到对象类型 构造函数模式 1234567function createCake(name)&#123; this.name=name; this.sayName=function()&#123; console.log(&apos;我是：&apos;+this.name); &#125;&#125;var cake1= new createCake(&apos;草莓蛋糕&apos;) 原型方式 1234567function createCake(name)&#123; this.name=name;&#125;createCake.prototype.sayName=function()&#123; console.log(&apos;我是：&apos;+this.name); &#125;var cake1= new createCake(&apos;草莓蛋糕&apos;) 下面两种写法有什么区别?12345678910111213141516171819function People(name, sex)&#123; this.name = name; this.sex = sex; this.printName = function()&#123; console.log(this.name); &#125;&#125;var p1 = new People(&apos;饥人谷&apos;, 2)//方法2function Person(name, sex)&#123; this.name = name; this.sex = sex;&#125;Person.prototype.printName = function()&#123; console.log(this.name);&#125;var p1 = new Person(&apos;若愚&apos;, 27); 方法一是构造函数模式，方法二是原型模式。方法二算是方法一的一种改进，把共有的属性放在了原型当中，节省空间。 Object.create 有什么作用？兼容性如何？如何使用？Object.create创建一个拥有指定原型和若高个指定属性的对象ES5新特性，需要IE9以上版本 hasOwnProperty有什么作用？ 如何使用？可以判断一个对象是否包含自定义属性而不是原型链上的属性，hasOwnProperty是JS中唯一一个处理属性但是不查找原型链的函数。 实现Object.create的 polyfill,如：（ps: 写个 函数create，实现 Object.create 的功能)123var obj = &#123;a: 1, b:2&#125;;var obj2 = create(obj);console.log(obj2.a); //1 12345678910111213141516171819202122232425if (typeof Object.create != &apos;function&apos;)&#123; Obj.create = (function()&#123; function Temp() &#123;&#125; var hasOwn = Object.prototype.hasOwnProperty; return function(proto)&#123; if (typeof proto != &apos;object&apos;)&#123; throw TypeError(&apos;Object prototype may only be an Object or null&apos;); &#125; Temp.prototype = proto; var obj = new Temp(); Temp.prototype = null; if (arguments.length &gt; 1)&#123; var Properties = Object(arguments[1]); for (var prop in Properties)&#123; if (hasOwn.call(Properties, prop)) &#123; obj[prop] = Properties[prop]; &#125; &#125; &#125; return obj; &#125;; &#125;)();&#125; 如下代码中call的作用是什么?12345678function Person(name, sex)&#123; this.name = name; this.sex = sex;&#125;function Male(name, sex, age)&#123; Person.call(this, name, sex); //这里的 call 有什么作用 this.age = age;&#125; 改变this的指向，把环境改变到Male的环境内，实现继承。 补全代码，实现继承12345678910111213141516171819function Person(name, sex)&#123; // todo ...&#125;Person.prototype.getName = function()&#123; // todo ...&#125;;function Male(name, sex, age)&#123; //todo ...&#125;//todo ...Male.prototype.getAge = function()&#123; //todo ...&#125;;var ruoyu = new Male(&apos;若愚&apos;, &apos;男&apos;, 27);ruoyu.printName(); 1234567891011121314151617181920 function inhert(superType,subType)&#123; var _prototype = Object.create(superType.prototype); _prototype.constructor=subType; subType.prototype=_prototype;&#125;function Person(name,sex)&#123; this.name=name; this.sex=sex;&#125;Person.prototype.getName=function()&#123; console.log(this.name);&#125;function Male(name,sex,age)&#123; Person.call(name,sex); this.age=age;&#125;inhert(Person,Male);Male.prototype.getAge=function()&#123; console.log(this.age);&#125;","tags":[]},{"title":"原型链","date":"2016-10-07T16:00:00.000Z","path":"2016/10/08/原型链/","text":"有如下代码，解释Person、 prototype、proto、p、constructor之间的关联。12345678function Person(name)&#123; this.name = name;&#125;Person.prototype.sayName = function()&#123; console.log(&apos;My name is :&apos; + this.name);&#125;var p = new Person(&quot;若愚&quot;)p.sayName(); Person是一个函数，本身也是一个对象，拥有prototype属性，而prototype拥有constructor、__proto__两个对象成员。p是由构造函数方法创造的对象，其本身也具有__proto__属性，该属性指向prototype对象。 上例中，对对象 p可以这样调用 p.toString()。toString是哪里来的? 画出原型图?并解释什么是原型链。每一个对象都有一个__proto__属性，这个属性指向该对象的原型对象，而原型对象也有一个__proto__指向自己的原型对象，这种关系一直到Object对象结束。 对String做扩展，实现如下方式获取字符串中频率最高的字符123var str = &apos;ahbbccdeddddfg&apos;;var ch = str.getMostOften();console.log(ch); //d , 因为d 出现了5次 12345678910111213141516171819202122var str = &apos;ahbbccdeddddfg&apos;;String.prototype.getMostOften=function()&#123; var times=&#123;&#125;; for(var i=0;i&lt;this.length;i++)&#123; if(!times[this.charAt(i)])&#123; times[this.charAt(i)]=1; &#125;else&#123; times[this.charAt(i)]++; &#125; &#125; var num=0; var word; for(var key in times)&#123; if(times[key]&gt;num)&#123; num=times[key]; word=key; &#125; &#125; return word;&#125;;var ch = str.getMostOften();console.log(ch); //d , 因为d 出现了5次 JSBin instanceOf有什么作用？内部逻辑是如何实现的？instanceof运算符用来测试一个对象在其原型链构造函数上是否具有prototype属性12345678function instanceOf(obj,Func)&#123; var __proto__=obj.__proto__; do&#123; if(__proto__===Func.prototype) return true; if(!__proto__) return false; &#125;while(__proto__=__proto__.__proto__) return false;&#125;","tags":[]},{"title":"对象、原型","date":"2016-09-27T16:00:00.000Z","path":"2016/09/28/对象、原型/","text":"OOP 指什么？有哪些特性Object-Oriented Programming：面向对象程序设计，是中具有对象概念的程序编程泛型，同时也是一种程序开发方法。特性： 封装：就是把客观事务封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行隐藏 继承：它可以使用现有类的所有功能，并且在无需重新编写原来的类的情况下对这些功能进行扩展 多态：允许将父对象设置成和一个或更多的他的子对象的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。 如何通过构造函数的方式创建一个拥有属性和方法的对象?1234567function People(name,age)&#123; this.name=name; this.age=age;&#125;People.prototype.say=function()&#123; console.log(this.name+&apos;已经&apos;+this.age+&apos;岁了&apos;);&#125; prototype 是什么？有什么特性prototype：是函数天生具有的属性，该属性是一个对象。这个对象具有两个属性，一个是constructor指的是函数本身，另一个是__proto__由原型对象创造。特性：当用new构造一个对象时，就得到了该函数构造函数的实例。实例继承prototype的所有属性和方法。 画出如下代码的原型图1234567891011function People (name)&#123; this.name = name; this.sayName = function()&#123; console.log(&apos;my name is:&apos; + this.name); &#125;&#125;People.prototype.walk = function()&#123; console.log(this.name + &apos; is walking&apos;);&#125;var p1 = new People(&apos;饥人谷&apos;);var p2 = new People(&apos;前端&apos;); 以下代码中的变量age有什么区别1234567function People ()&#123; var age = 1 //局部变量 this.age = 10; //把age绑定为window属性&#125;People.age = 20;//函数自身属性People.prototype.age = 30;//给函数的原型绑定属性，如果以后通过new构造对象则为大家的共有属性。 代码创建一个 Car 对象，拥有属性name、color、status；拥有方法run，stop，getStatus12345678910111213141516function Car(name,color,status)&#123; this.name=name; this.color=color; this.status=status;&#125;Car.prototype=&#123; run:function()&#123; console.log(&quot;开车&quot;); &#125;， stop:function()&#123; console.log(&quot;停车&quot;); &#125;, getStatus:function()&#123; return this.status; &#125;&#125; 回到顶部轮播tab切换","tags":[]},{"title":"HTTP","date":"2016-09-26T16:00:00.000Z","path":"2016/09/27/HTTP/","text":"OSI 七层模型指什么？ 物理层：将电脑链接起来的物理手段，用来传输0和1的电信号 数据链路层：确定0和1的分组方式，确定了网络数据包的形式。 网络层：引进网址，用以区分各个电脑是否处于同一个子网络 传输层：建立端口到端口的通信，实现程序之间的交流，比如一个接收到一个数据包，数据包是用来网页还是聊天，就要根据对应的端口来判断 会话层：在系统之间建立会话 表示层：确保一个系统所发送的数据可以被接收方读取，负责数据格式的转换，数据的加密、解压、压缩。 应用层：规定应用程序的数据格式。 HTTP 的工作原理是什么？一次HTTP操作称为一个事务，其工作可分为四步： 客户机与服务器需要建立链接，只要单击摸个超级链接，HTTP的工作就开始了 建立链接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容。 服务器接到请求后，给予相应的响应信息其格式为一个状态行，暴扣信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括请求修饰符、客户机信息和可能的内容。 客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开链接。 URI 的格式是什么？常见的协议有哪些URI：统一资源标识符，是更通用的资源标识符，URL是他的一个子集。URI由两个子集构成 URL：通过描述资源的位置来描述资源 URN：通过名字来识别资源和位置无关 组成部分：1&lt;scheme&gt;://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;path&gt;;&lt;params&gt;?&lt;query&gt;#&lt;hash&gt; &lt;scheme&gt;：对于web页面来说最常用的协议就是http和https &lt;user&gt;:&lt;password&gt;：user和password现在不常见了 &lt;host&gt;：主机可以使IPO地址或域名 &lt;port&gt;：端口号用来区分主机上的进程，方便查找web服务器 &lt;path&gt;：资源的路径，也就是存放的位置，不一定和物理路径完全对应，符合web服务器路由约定即可 &lt;params&gt;：在一些协议中需要参数来访问资源 &lt;query&gt;：这个是get请求最常用的传递参数方式 &lt;hash&gt;：也称为片段，设计为标识文档的一部分，很多MVVM框架用作了路由功能 常见协议：http，https，ftp，mailto等 HTTP 协议有几种和服务器交互的方法 GET：请求服务器获取某个资源 POST：向服务器传送数据 HEAD：与GET相似，请求服务器响应信息报头 DELETE：请求服务器删除对应的URL PUT：请求服务器写入一个资源 TRACE：请求服务器将收到的请求信息发回 OPTIONS：请求查询服务器的性能，或查询与资源相关的选项和需求 状态码200，301， 304，403,404,500，503分别代表什么意思 200：请求被服务器成功处理 301：永久性重定向 304：页面使用本地缓存，不像服务器发送请求 403：服务器接收到请求，但是拒绝访问 404：请求的资源找不到 500：服务器执行请求发生错误 503：服务器超负载或停机维护 报文有哪几部分组成？ HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成. HTTP响应报文由三个部分组成，分别是：状态行(status-line)、消息报头(headers)、响应正文(response-body) 请求头的格式和作用是什么？给个范例截图说明 Accept：告诉服务器浏览器能接收的数据类型 Accept-Enocoding：能接受的压缩格式类型 Accept-Language：告诉服务器能发送的语言 Cache-Control：缓存指示 Cookie：客户端信息 Host：请求的域名 首部的格式和作用是什么？给个范例截图说明 Request URL：请求的URL Request Method：请求的方法 Status Code：请求的状态 Remote Address：服务器ip和端口 主体的作用是什么？给个范例主体就是客户端和服务端之间传输的主要内容 简述浏览器缓存是如何控制的浏览器第一次请求：浏览器再次请求： Expires策略：是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求 Cache-control策略：与Expires作用一致，都是指明当前资源的有效期。只不过选择更多，设置更细致，其优先级高于Expires浏览器缓存参考","tags":[]},{"title":"this","date":"2016-09-26T16:00:00.000Z","path":"2016/09/27/this/","text":"apply、call 有什么作用，什么区别 首先要引入this这个概念由于运行期绑定的特性，this的含义非常多，既可以是全局对性爱那个，当前对象或任意对象，这取决于函数的调用方式，但总有一个原则，那就是this指的是调用函数的那个对象。 作为函数调用：在函数直接调用时this绑定到全局对象，在浏览器中，window就是该全局对象。 内部函数：函数嵌套产生的内部函数的this不是其父函数，仍是全局变量。 setTimeout、setinterval：这两个方法执行的函数this也是全局对象 作为构造函数调用：所谓构造函数，就是通过这个函数生成一个新对象。这时，this就指这个新对象。 new 运算符接受一个函数 F 及其参数：new F(arguments…)。这一过程分为三步： 创建类的实例。这步是把一个空的对象的 proto 属性设置为 F.prototype 。 初始化实例。函数 F 被传入参数并调用，关键字 this 被设定为该实例。 返回实例。 作为对象方法调用：在JS中，函数也是对象，因此函数可以作为一个对象的属性，此时该函数被称为该对象的方法，在使用这种调用方法时，this被自然绑定到该对象。 DOM对象绑定事件：在事件处理程序中this代表事件源DOM对象（低版本IE被指向了window） apply、call的作用apply、call的作用是相同的，都是指定函数的this和参数来调用函数，使用call和apply可以使this的指向变得清晰。 apply、call的区别apply接受的是数组形式的参数，call接受的是多个参数。 代码 以下代码输出什么？12345678var john = &#123; firstName: &quot;John&quot;&#125;function func() &#123; alert(this.firstName + &quot;: hi!&quot;)&#125;john.sayHi = funcjohn.sayHi() 输出john：hi！ 下面代码输出什么，为什么1234func()function func() &#123; alert(this)&#125; 输出window，因为函数是全局作用域下调用的 下面代码输出什么 12345678910111213function fn0()&#123; function fn()&#123; console.log(this); &#125; fn();&#125;fn0(); //输出windowdocument.addEventListener(&apos;click&apos;, function(e)&#123; console.log(this); //输出document节点 setTimeout(function()&#123; console.log(this); //输出window &#125;, 200);&#125;, false); 下面代码输出什么，why 1234567var john = &#123; firstName: &quot;John&quot;&#125;function func() &#123; alert( this.firstName )&#125;func.call(john) 输出John，因为通过call把this指为了john对象 代码输出？12345678var john = &#123; firstName: &quot;John&quot;, surname: &quot;Smith&quot;&#125;function func(a, b) &#123; alert( this[a] + &apos; &apos; + this[b] )&#125;func.call(john, &apos;firstName&apos;, &apos;surname&apos;) 输出John Smith 以下代码有什么问题，如何修改123456789101112var module= &#123; bind: function()&#123; var cur=this; //添加 $btn.on(&apos;click&apos;, function()&#123; console.log(this) //this指什么 cur.showMsg();//改 &#125;) &#125;, showMsg: function()&#123; console.log(&apos;饥人谷&apos;); &#125;&#125; 在DOM绑定事件中this被指向了事件源DOM对象，所以this.showMsg()无法正常调用","tags":[]},{"title":"同源策略、跨域、jsonp","date":"2016-09-21T16:00:00.000Z","path":"2016/09/22/同源策略、跨域、jsonp/","text":"什么是同源策略同源策略是浏览器的一个功能，就是协议、域名、端口号都相同。对于不同源的客户端脚本再一般情况下只能引用二不可以读写。 什么是跨域？跨域有几种实现形式处于安全方面考虑，不允许跨域调用其他页面的对象。简单的理解就是因为JS同源策略的限制，a.com域名下的JS无法操作b.com域名下的对象资源。跨域的形式： 降域 JSONP CORS postMessage 其他hack 降域是什么在iframe形势下将两个不同源的URL变成同源状态通过给当前页面和iframe页面同时加上document.domain=当前页面进行降域处理.弊端： 只能再iframe形式有用 降域只能设置为父域名 安全问题 jsonp 的原理是什么jsonp可以看作是动态添加script。 在html中声明一个方法，给目标路由发送一个callback=方法的参数 返回路由中JS内容，再调用这个方法 弊端： 只能在GET请求中使用 可能被注入(callback=function(){})，要靠外界字符串过滤 12callback = callback.replace(&apos;/\\(/g&apos;,&apos;&apos;)callback = callback.replace(&apos;/\\)/g&apos;,&apos;&apos;) 为了安全性，需要检验身份 CORS是什么CORS是HTTP2的方法。它允许浏览器向跨域服务器发出XMLHttpRequest请求，从而客服AJAX只能同源使用的限制，简单来说就是在头信息之中增加一个Origin字段 演示没有解决跨域问题： JSONP解决:123456var script = document.createElement(&apos;script&apos;);window.xxx = function(data)&#123;//给XXX绑定一个函数方法 alert(data)&#125;script.src = &apos;//b.com:3000/test/ajax.php?callback=xxx&apos;;//传一个callback=xxx的参数给后台document.body.appendChild(script) CORS解决：对于简单请求来说，只要在后台文件中添加一句话就可以解决","tags":[]},{"title":"jquery懒加载","date":"2016-09-18T16:00:00.000Z","path":"2016/09/19/jquery懒加载/","text":"如何判断一个元素是否出现在窗口可视范围（浏览器的上边缘和下边缘之间，肉眼可视）。写一个函数 isVisible实现12345678910function isVisible($node)&#123; var scrollTop=$(window).scrollTop(), winH=$(window).height(), offsetTop=$node.offset().top; if(scrollTop+winH&gt;offsetTop$$scrollTop&lt;offsetTop)&#123; return true; &#125;else&#123; return false; &#125;&#125; 当窗口滚动时，判断一个元素是不是出现在窗口可视范围。每次出现都在控制台打印 true 。用代码实现12345$(window).on(&apos;scroll&apos;,function()&#123; if(isVisible($node))&#123; console.log(true); &#125;&#125;) JSbin 当窗口滚动时，判断一个元素是不是出现在窗口可视范围。在元素第一次出现时在控制台打印 true，以后再次出现不做任何处理。用代码实现12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JS Bin&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;内容&lt;/p&gt; &lt;p&gt;内容&lt;/p&gt; &lt;p&gt;内容&lt;/p&gt;&lt;p&gt;内容&lt;/p&gt;&lt;p&gt;内容&lt;/p&gt;&lt;p&gt;内容&lt;/p&gt;&lt;p&gt;内容&lt;/p&gt;&lt;p&gt;内容&lt;/p&gt;&lt;p&gt;内容&lt;/p&gt;&lt;p&gt;内容&lt;/p&gt;&lt;p&gt;内容&lt;/p&gt;&lt;p&gt;内容&lt;/p&gt;&lt;p&gt;内容&lt;/p&gt;&lt;p&gt;内容&lt;/p&gt;&lt;p&gt;内容&lt;/p&gt;&lt;p&gt;内容&lt;/p&gt;&lt;p&gt;内容&lt;/p&gt;&lt;p&gt;内容&lt;/p&gt;&lt;p&gt;内容&lt;/p&gt;&lt;p&gt;内容&lt;/p&gt;&lt;p&gt;内容&lt;/p&gt;&lt;p&gt;内容&lt;/p&gt;&lt;p&gt;内容&lt;/p&gt;&lt;p&gt;内容&lt;/p&gt; &lt;p class=&quot;test&quot;&gt;测试&lt;/p&gt; &lt;script src=&quot;http://apps.bdimg.com/libs/jquery/1.9.1/jquery.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var $test=$(&apos;.test&apos;); $test.data(&apos;flag&apos;,true); function isVisible($node)&#123; var scrollTop=$(window).scrollTop(), winH=$(window).height(), offsetTop=$node.offset().top; if(scrollTop+winH&gt;offsetTop&amp;&amp;scrollTop&lt;offsetTop)&#123; return true; &#125;else&#123; return false; &#125; &#125; $(window).on(&apos;scroll&apos;,function()&#123; if(isVisible($test)&amp;&amp;$test.data(&apos;flag&apos;))&#123; console.log(true); $test.data(&apos;flag&apos;,false); &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; JSbin 图片懒加载的原理是什么？懒加载即曝光加载，当图片曝光在你眼前的时候再去加载。如果网页中有较多图片，为优化渲染速度，图片可以先使用一张占位图片显示,真实的图片地址保存在一个自定义的属性当中,当图片出现在窗口的可是范围的时候,才将真实的地址替换掉占位图片的地址","tags":[]},{"title":"瀑布流布局","date":"2016-09-18T16:00:00.000Z","path":"2016/09/19/瀑布流布局/","text":"###瀑布流布局的原理是什么元素的宽度统一固定，但是高度随机。通过计算窗口的宽度确定每排最多可以并列几个元素。然后先顺序插入一排元素，再之后每个元素插入的时候都找高度最小的那一列插入。由于在使用过程中窗口的宽度可能会改变，则要将以上的过程中放在window.onresize事件当中。 ###瀑布流布局代码在线预览","tags":[]},{"title":"jQuery常用方法及ajax","date":"2016-09-10T16:00:00.000Z","path":"2016/09/11/jQuery常用方法及ajax/","text":"jquery 中， $(document).ready()是什么意思？和window.onload 的区别？ 还有其他什么写法或者替代方法？123 $(document).ready(function()&#123;&#125;)简写方式$(function()&#123;&#125;) 作用是放置文档在完全加载之前运行就运行代码，有可能导致部分操作失败区别： $(document).ready()表示DOM加载完成之后就可以对DOM进行操作 window.onload表示在文档加载完成之后就可以对DOM进行操作，包含图片加载信息 $node.html()和$node.text()的区别?$node.html()：设置或返回所选元素内容（包括元素标记）$node.text()：设置或返回所选元素的文本内容 $.extend 的作用和用法?$.extend：将两个或更多对象的内容合并到第一个对象。用法 jQuery.extend( target [, object1 ] [, objectN ] )当我们提供两个或多个对象给$.extend()，对象的所有属性都添加到目标对象（target参数）。目标的第一个参数将被修改，并且通过$.extend()返回，如果想保留原对象则：$.extend({},obj1,obj2)如果后面提供的对象中有属性相同，则后面属性的值会覆盖前面的属性的值。 jQuery.extend( [deep ], target, object1 [, objectN ] )如果deep的值为true,则会发生深拷贝 JQuery 的链式调用是什么？当jQuery的方法的返回值仍为当前对象时可以继续调用该对象的方法，这样就形成一种链式调用 JQuery ajax 中缓存怎样控制?通过cache属性来控制缓存，当设置为false的时候则不会缓存当前页面 jquery 中 data 函数的作用在匹配元素上存储任意相关数据或返回匹配的元素集合中的第一个元素的给定名称的数据存储的值$.data( key, value ).data()方法允许我们在DOM元素上绑定任意类型的数据,避免了循环引用的内存泄漏风险。 代码代码一、二代码三","tags":[]},{"title":"jquery","date":"2016-09-05T16:00:00.000Z","path":"2016/09/06/jquery/","text":"说说库和框架的区别？库是将代码集合成的一个产品，供程序员调用。面向对象的代码组织形式而成的库也叫类库。面向过程的代码组织形式形成的也叫函数库。再函数库中可直接使用的函数叫库函数。开发者在使用库的时候，只需要使用库的一部分类或函数，然后继续实现自己的功能。框架则是为解决一个（一类）问题而开发的产品，框架用户一般只需要使用框架提供的类或函数，即可实现全部功能。也就是说框架是库的升级版。开发者使用框架的时候，必须使用这个框架的全部代码。 jquery 能做什么？jquery是个轻量级的“写的少，做的多”的js库。jQuery的功能： HTML元素选取 HTML元素操作 CSS操作 HTML事件函数 JavaScript特效和动画 HTML DOM遍历和修改 AJAX jquery 对象和 DOM 原生对象有什么区别？如何转化？ jQeury对象是通过jQuery的API构造的jQuery对象（类数组），拥有自己的属性和方法。 DOM原生对象是通过DOM的API构造的DOM对象（DOM节点），也拥有自己的属性和方法。 12345678var $jquery=$(&apos;#jquery&apos;);var dom=document.getElementById(&apos;dom&apos;);//dom对象转化为jquery对像var $dom=$(dom);//jquery对象转化为dom对象var jquery=$jquery[0];//对于一个特定的结果集，获取指定index的jQuery对象$jquery.eq(0); jquery中如何绑定事件？bind、unbind、delegate、live、on、off都有什么作用？推荐使用哪种？使用on绑定事件使用事件代理的写法？可以像原生dom一样绑定事件$(selector).click()jQuery也可以使用bind()/delegate()/live()/on绑定事件，unbind()和off()为对应bind()和on()解绑事件 bind()为一个元素绑定一个事件处理程序，再jQuery1.7以前使用。对于早期版本，.bind()方法用于直接附加一个事件处理程序到元素上。处理程序附加到jQuery对象当前选中的元素、所以在绑定的时候这些元素必须已经存在。基本用法： 123$(&apos;#foo&apos;).bind(&apos;click&apos;, function() &#123; alert(&apos;User clicked on &quot;foo.&quot;&apos;);&#125;); .delegate()为所有匹配选择器的元素绑定一个或多个事件处理函数，基于一个指定的根元素的子集，匹配的元素包括那些目前已经匹配到的元素，也包括那些今后可能匹配到的元素。从1.7版本开始已被取代。使用方法： 123$(&quot;table&quot;).on(&quot;click&quot;, &quot;td&quot;, function() &#123; $(this).toggleClass(&quot;chosen&quot;);&#125;); .live()附加一个事件处理程序到匹配目前选择器的所有元素，现在和未来从jQuery1.7开始， .live()方法已经过时了。基本用法： 1$(&quot;a&quot;).live(&quot;click&quot;, function() &#123; return false; &#125;) .on( events [,selector ] [,data ], handler(eventObject) )推荐在选定的元素上绑定一个或多个事件处理函数从1.7版本之后，.on()方法提供了绑定事件的所有功能。 各个参数的意义： events：一个或多个空格分割的事件类型和可选择的命名空间，或仅仅是命名空间。 selector：一个选择器字符串，用于过滤出被选中的元素中能触发事件的后代元素。若果选择器是null或忽略了该选择器，那么被选中的元素总是能触发事件。 data：当一个事件被触发时，要传递给事件处理函数event.data handler(eventObject)：事件被触发时，执行的函数。1234567891011121314//普通绑定事件$(&apos;div&apos;).on(&apos;click&apos;,function(e)&#123; console.log(this); console.log(e);&#125;)//事件委托或者事件代理，想让div 下面所有的span绑定事件，可以把事件绑定到div上$(&apos;div&apos;).on(&apos;click&apos;, &apos;span&apos;, function(e)&#123; console.log(this); console.log(e);&#125;);// 可以在绑定的时候给事件处理程序传递一些参数$(&apos;div&apos;).on(&apos;click&apos;, &#123;name: &apos;Byron&apos;, age: 24&#125;, function(e)&#123; console.log(e.data);&#125;); jquery 如何展示/隐藏元素？ 隐藏元素：.hide([duration][,easing][,complete]) 用于隐藏元素，没有参数的时候等同于直接设置display属性。.css(&#39;display&#39;,&#39;none&#39;) duration：动画持续多久 easing：表示过渡时使用那种缓冲函数，jquery自身提供linear和swing complete：动画完成时执行的函数 参考 显示元素：.show( [duration ] [, easing ] [, complete ] )用法类似于hide。 参考Jsbin jquery 动画如何使用？jQuery animate() 方法用于创建自定义动画。$(selector).animate({params},speed,callback);参数： 必需的 params 参数定义形成动画的 CSS 属性。 可选的 speed 参数规定效果的时长。它可以取以下值：”slow”、”fast” 或毫秒。 可选的 callback 参数是动画完成后所执行的函数名称。 如何设置和获取元素内部 HTML 内容？如何设置和获取元素内部文本？ text()：设置或返回所选元素的文本内容 html()：设置或返回所选元素的内容(包括HTML标记) 如何设置和获取表单用户输入或者选择的内容？如何设置和获取元素属性？ val() ：设置或返回表单字段的值 attr()：设置或返回元素的属性 代码使用 jquery实现如下效果在线预览 使用 jquery 实现如下效果问题： 点奢侈品2的时候页面跳到了顶部，可能是什么原因？如何解决原因是在href属性中使用了#做页面跳转，可以使用javascript:void(0)在线预览 实现如下效果提示1.使用代理2.当点击按钮时使用如下数据 123456789101112131415var products = [ &#123; img: &apos;http://img10.360buyimg.com/N3/jfs/t2242/92/1446546284/374195/9196ac66/56af0958N1a723458.jpg&apos;, name: &apos;珂兰 黄金手 猴哥款&apos;, price: &apos;￥405.00&apos; &#125;,&#123; img: &apos;http://img10.360buyimg.com/N3/jfs/t2242/92/1446546284/374195/9196ac66/56af0958N1a723458.jpg&apos;, name: &apos;珂兰 黄金转运珠 猴哥款&apos;, price: &apos;￥100.00&apos; &#125;,&#123; img: &apos;http://img10.360buyimg.com/N3/jfs/t2242/92/1446546284/374195/9196ac66/56af0958N1a723458.jpg&apos;, name: &apos;珂兰 黄金手链 3D猴哥款&apos;, price: &apos;￥45.00&apos; &#125;]; 在线预览","tags":[]},{"title":"AJAX","date":"2016-08-30T16:00:00.000Z","path":"2016/08/31/AJAX/","text":"ajax 是什么？有什么作用？ajax通过原生的XMLHttpRequest对象发出HTTP请求，得到服务器返回的数据后，再进行处理。ajax可以无需刷新整个网页，而是对部分网页进行刷新。 ###前后端开发联调需要注意哪些事情？后端接口完成前如何 mock 数据？前后端进行开发前，要定义好接口以及数据形式等细节，已达到解耦效果。后端接口完成前，前端可以通过MOCKJS等工具模拟数据。 点击按钮，使用 ajax 获取数据，如何在数据到来之前防止重复点击?通过设定标记12345678var flag=false;tn.addEventListener(&apos;click&apos;, function(e) &#123; //...... flag = true; if(flag)&#123; return; &#125;&#125;); 在请求数据时，函数flag设为false,保证不重复点击 代码 封装一个 ajax 函数，能通过如下方式调用12345678910111213141516171819function ajax(opts)&#123; // todo ...&#125;document.querySelector(&apos;#btn&apos;).addEventListener(&apos;click&apos;, function()&#123; ajax(&#123; url: &apos;getData.php&apos;, //接口地址 type: &apos;get&apos;, // 类型， post 或者 get, data: &#123; username: &apos;xiaoming&apos;, password: &apos;abcd1234&apos; &#125;, success: function(ret)&#123; console.log(ret); // &#123;status: 0&#125; &#125;, error: function()&#123; console.log(&apos;出错了&apos;) &#125; &#125;)&#125;); 实现：123456789101112131415161718192021222324252627function ajax(opts)&#123; var xmlhttp = new XMLHttpRequest(); xmlhttp.onreadystatechange = function()&#123; if(xmlhttp.readyState == 4 &amp;&amp; xmlhttp.status == 200)&#123; var ret = JSON.parse(xmlhttp.responseText); opts.success(ret); &#125; if(xmlhttp.status == 404)&#123; opts.error(); &#125; &#125;; var dataStr = &apos;&apos;; for(var key in opts.data)&#123; dataStr += key + &apos;=&apos; + opts.data[key] + &apos;&amp;&apos;; &#125; dataStr = dataStr.substr(0,dataStr.length-1); if(opts.type.toLowerCase() == &apos;post&apos;)&#123; xmlhttp.open(opts.type,opts.url,true); xmlhttp.setRequestHeader(&apos;Content-type&apos;, &apos;application/x-www-form-urlencoded&apos;); xmlhttp.send(dataStr); &#125; if(opts.type.toLowerCase() == &apos;get&apos;)&#123; xmlhttp.open(opts.type,opts.url+&apos;?&apos;+dataStr,true); xmlhttp.send(); &#125;&#125; 实现如下加载更多的功能。效果如下： http://jrgzuoye.applinzi.com/作业安排/jscode/JS9-jqueryajax/1.html新浪云源码 实现注册表单验证功能效果如下：http://jrgzuoye.applinzi.com/作业安排/jscode/JS7-ajax/3.html新浪云源码","tags":[]},{"title":"熟悉后端语言","date":"2016-08-28T16:00:00.000Z","path":"2016/08/29/熟悉后端语言/","text":"简单描述下web 服务器、PHP、数据库、浏览器是如何实现动态网站的? 用户端访问服务端的HTML文件 通过本机配制好的DNS域名地址寻找DNS服务器，将URL中的web主机域名解析为服务器的对应IP地址。 通过HTTP协议链接服务器系统，通过默认端口请求服务器上相应目录下的html文件 服务器接受到访问请求后，在管理的文档目录中打开相应的html文件，将文件内容响应到客户端。 浏览器接受到服务器响应后下载HTML代码并进行解析，将网页呈现 用户端访问服务端php文件 通过DNS解析响应IP地址 通过HTTP协议链接服务器系统，通过默认端口请求服务器上相应目录下的php文件 如果服务器本身不能处理php语言，则委托给php应用服务器来处理，将用户请求访问的php文件交给php应用服务器 php应用服务器接收文件后，打开并解释文件，最终翻译成静态HTML代码再交回给原来的服务器，再将静态代码输出到客户端 浏览器接受到服务器响应后下载HTML代码并进行解析，将网页呈现 用户端访问服务器端MySQL数据库想要解析数据库中的数据并操作，则需要安装数据库管理软件MySQL服务器，用来存储和管理网站数据。对于无法链接MySQL服务器的服务器还需要安装php应用服务器。 通过DNS解析响应IP地址 与上面访问php文件一样，请求访问Apache服务器上相应目录下的php文件。 与上面访问php文件一样，PHP应用服务器接收Apache服务器的委托，收到相应的php文件。 HP应用服务器打开php文件，在php文件中通过对数据库连接的代码来连接本机或者网络上其他机器上的MySQL数据库，并在php程序中通过执行标准的SQL查询语句来获取数据库中的数据，再通过PHP应用服务器将数据生成html静态代码。 浏览器接受到服务器响应后下载HTML代码并进行解析，将网页呈现 常见的 WEB 服务器有哪些？ Apache软件基金会的Apache HTTP服务器 Microsoft的Internet Information Server(IIS) Google的Google Web Server Nginx公司的nginx 淘宝的TENGINE lighttpd公司的lighttd Cherokee_（Web服务器） Microsoft的FrontPage 打开浏览器，在地址栏输入 http://jirengu.com 页面展现了饥人谷官网的信息，整个过程发生了什么？（饥人谷官网后台语言 php,web服务器 nginx，数据库 mysql） 输入URL开始解析域名，查找到相对应的IP地址 浏览器将用户的请求发送给nginx服务器 服务器分析用户请求，查找对应文件 若要处理PHP文件或链接数据库，则把相应请求委托给PHP应用服务器，生成HTML静态代码后再发送给nginx服务器 浏览器接受到服务器响应后下载HTML代码并进行解析，将网页呈现xmapp:sae:","tags":[]},{"title":"DOM、事件","date":"2016-08-25T16:00:00.000Z","path":"2016/08/26/DOM、事件/","text":"dom对象的innerText和innerHTML有什么区别？innerText：返回元素内包含的文本内容，在多层次的时候会按照元素由浅到深的顺序拼接其内容。innerHTML：类似innerText，但是返回的是元素的HTML结构，在写入的时候会自动构建DOM。12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JS Bin&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;div1&quot;&gt; 测试 &lt;/div&gt; &lt;div id=&quot;div2&quot;&gt; 测试 &lt;/div&gt; &lt;script&gt; var div1=document.getElementById(&apos;div1&apos;); var div2=document.getElementById(&apos;div2&apos;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; elem.children和elem.childNodes的区别？elem.children：子列表元素（HTMLCollention）获取标签elem.childNodes:（NodeList）获取所有子节点，包括空白的所有字段123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JS Bin&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;div1&quot;&gt; &lt;p&gt;测试&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var div1=document.getElementById(&apos;div1&apos;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 查询元素有几种常见的方法？ document.getElementById()：获得id元素 document.getElementsByClassName()：获得class元素 document.getElementsByTagName()：返回带有指定标签名的对象的集合。 document.querySelector()：返回当前文档中第一个匹配特定选择器的元素 document.querySelectorAll()：返回当前文档中匹配一个特定选择器的所有的元素 如何创建一个元素？如何给元素设置属性？创建元素： createElement()：创建元素节点 createTextNode()：创建文本节点 createDocumentFragment()：生成一个DocumentFragment对象。12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JS Bin&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;div1&quot;&gt; &lt;/div&gt; &lt;script&gt; var para=document.createElement(&apos;p&apos;); var div=document.getElementById(&apos;div1&apos;); div.appendChild(para); var text=document.createTextNode(&apos;段落&apos;); para.appendChild(text); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; JSbin 设置元素属性： getAttribute()：获取属性 createAttribute()：生成一个新的属性对象节点，并返回它 setAttributeNode()：添加属性节点 setAttribute()：设置元素属性 removeAttitbute()：删除属性12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JS Bin&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;div1&quot;&gt; &lt;a class=&apos;link&apos; href=&quot;#&quot;&gt;链接&lt;/a&gt; &lt;/div&gt; &lt;script&gt; var div=document.querySelector(&apos;#div1&apos;); console.log(div1.getAttribute(&apos;id&apos;)); var link=document.querySelector(&apos;.link&apos;); link.setAttribute(&apos;title&apos;,&apos;测试&apos;); link.removeAttribute(&apos;href&apos;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; JSbin 元素的添加、删除？ newDiv.appendChild(newContent)：在元素末尾添加元素 newDiv .insertBefore(newContent，newDiv.firstChild)：在某个元素之前添加元素 newDiv.replaceChild(newElement, oldElement)：接收两个元素，要添加的元素和要替换的元素 parentNode.removeChild(childNode)：删除元素123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JS Bin&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;div1&quot;&gt; &lt;p class=&quot;para&quot;&gt;段落&lt;/p&gt; &lt;p class=&apos;para&apos;&gt;段落2&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var div1=document.querySelector(&apos;#div1&apos;); var text1=document.createTextNode(&quot;append&quot;); div1.appendChild(text1); var para=document.querySelectorAll(&apos;.para&apos;); var text2=document.createTextNode(&apos;insert&apos;); div1.insertBefore(text2,div1.children[0]); var text3=document.createTextNode(&quot;replace&quot;); para[0].replaceChild(text3,para[0].childNodes[0]); div1.removeChild(para[1]); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; JSbin DOM0 事件和DOM2级在事件监听使用方式上有什么区别？DOM0级事件：12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JS Bin&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;button class=&quot;btn&quot; onclick=&apos;console.log(1)&apos;&gt;点击&lt;/button&gt; &lt;script&gt; var btn=document.querySelector(&apos;.btn&apos;); btn.onclick=function()&#123; console.log(&apos;DOM0&apos;); &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; JSbin绑定方式： HTML内联方式 JS指定事件处理程序 DOM2级事件：12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JS Bin&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;button class=&quot;btn&quot;&gt;点击&lt;/button&gt; &lt;script&gt; var btn=document.querySelector(&apos;.btn&apos;); btn.addEventListener(&apos;click&apos;,function()&#123; console.log(&apos;DOM2&apos;); &#125;); btn.addEventListener(&apos;click&apos;,function()&#123; console.log(&apos;DOM2.2&apos;); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; JSbinDOM2addEventListener接收三个参数： 事件类型 事件处理函数 布尔参数，如果是true表示在捕获阶段调用事件处理程序，如果使false则是冒泡阶段处理程序，默认是false。 DOM0级和DOM2级区别 同样的事件，DOM2级可以绑定多种处理方式，而DOM0级绑定多种处理方式会被覆盖 DOM2级事件可以指定是否在捕获阶段进行程序处理 attachEvent与addEventListener的区别？ IE浏览器支持attachEvent，addEventListener支持多种主流浏览器 参数的个数不同 对this的引用不同，在attachEvent中this的环境是window，而addEventListener中this的环境是调用的元素 第一个参数意义不同，addEventListener第一个参数是事件类型（比如click，load），而attachEvent第一个参数指明的是事件处理函数名称（onclick，onload） 解释IE事件冒泡和DOM2事件传播机制？事件冒泡：从最具体的元素（事件发生的元素）接收，一层层向上传递到不具体的节点。所有的浏览器都支持事件冒泡，IE只支持事件冒泡。DOM2事件传播机制：DOM2事件规定的事件流包括三个阶段：首先发生的是事件捕获，为截取的事件提供机会，然后实际目标接收事件，最后再进行事件冒泡。 如何阻止事件冒泡？ 如何阻止默认事件？在主流浏览器中只要调用stopPropagation()，而在IE浏览器中要用cancelBubble。阻止默认事件主流浏览器中使用preventDefault()，而在IE浏览器中要用returnValue12345678910111213141516function stopPropagation(e)&#123; var event=e||window.event;//在IE浏览器中 事件是window.event if(event.stopPropagation)&#123; event.stopPropagation(); &#125;else&#123; event.cancleBubble=false;//IE浏览器中的阻止冒泡 &#125;&#125;function prevenDefault(e)&#123; var event=e||window.event; if(event.preventDefault)&#123; event.preventDefault(); &#125;else&#123; event.returnValue=false; &#125;&#125; 代码有如下代码，要求当点击每一个元素li时控制台展示该元素的文本内容。不考虑兼容12345678&lt;ul class=&quot;ct&quot;&gt; &lt;li&gt;这里是&lt;/li&gt; &lt;li&gt;饥人谷&lt;/li&gt; &lt;li&gt;前端6班&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;//todo ...&lt;/script&gt; 实现：1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JS Bin&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul class=&quot;ct&quot;&gt; &lt;li&gt;这里是&lt;/li&gt; &lt;li&gt;饥人谷&lt;/li&gt; &lt;li&gt;前端6班&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; var ct=document.querySelector(&apos;.ct&apos;); ct.addEventListener(&apos;click&apos;,function(e)&#123; console.log(e.target.innerText); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; JSbin 补全代码，要求： 当点击按钮开头添加时在&lt;li&gt;这里是&lt;/li&gt;元素前添加一个新元素，内容为用户输入的非空字符串；当点击结尾添加时在&lt;li&gt;前端6班&lt;/li&gt;后添加用户输入的非空字符串. 当点击每一个元素li时控制台展示该元素的文本内容。 1234567891011&lt;ul class=&quot;ct&quot;&gt; &lt;li&gt;这里是&lt;/li&gt; &lt;li&gt;饥人谷&lt;/li&gt; &lt;li&gt;前端6班&lt;/li&gt;&lt;/ul&gt;&lt;input class=&quot;ipt-add-content&quot; placeholder=&quot;添加内容&quot;/&gt;&lt;button id=&quot;btn-add-start&quot;&gt;开头添加&lt;/button&gt;&lt;button id=&quot;btn-add-end&quot;&gt;结尾添加&lt;/button&gt;&lt;script&gt;//todo ...&lt;/script&gt; 实现：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JS Bin&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul class=&quot;ct&quot;&gt; &lt;li&gt;这里是&lt;/li&gt; &lt;li&gt;饥人谷&lt;/li&gt; &lt;li&gt;前端6班&lt;/li&gt; &lt;/ul&gt; &lt;input class=&quot;ipt-add-content&quot; placeholder=&quot;添加内容&quot;/&gt; &lt;button id=&quot;btn-add-start&quot;&gt;开头添加&lt;/button&gt; &lt;button id=&quot;btn-add-end&quot;&gt;结尾添加&lt;/button&gt; &lt;script&gt; var ct=document.querySelector(&apos;.ct&apos;); var iptAdd=document.querySelector(&apos;.ipt-add-content&apos;); var btnAddStart=document.querySelector(&apos;#btn-add-start&apos;); var btnAddEnd=document.querySelector(&apos;#btn-add-end&apos;); btnAddStart.addEventListener(&apos;click&apos;,function()&#123; if(iptAdd.value)&#123; var text=document.createTextNode(iptAdd.value); var li=document.createElement(&apos;li&apos;); li.appendChild(text); ct.insertBefore(li,ct.children[0]); console.log(li.innerText); &#125; &#125;); btnAddEnd.addEventListener(&apos;click&apos;,function()&#123; if(iptAdd.value)&#123; var text=document.createTextNode(iptAdd.value); var li=document.createElement(&apos;li&apos;); li.appendChild(text); ct.appendChild(li); console.log(li.innerText); &#125; &#125;); ct.addEventListener(&apos;click&apos;,function(e)&#123; console.log(e.target.innerText); &#125;);/* btnAddEnd.addEventListener(&apos;click&apos;, function()&#123; var li = document.createElement(&apos;li&apos;); li.innerText = ipt.value; ct.appendChild(li); &#125;);*/ &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; JSbin 补全代码，要求：当鼠标放置在li元素上，会在img-preview里展示当前li元素的data-img对应的图片。123456789&lt;ul class=&quot;ct&quot;&gt; &lt;li data-img=&quot;1.png&quot;&gt;鼠标放置查看图片1&lt;/li&gt; &lt;li data-img=&quot;2.png&quot;&gt;鼠标放置查看图片2&lt;/li&gt; &lt;li data-img=&quot;3.png&quot;&gt;鼠标放置查看图片3&lt;/li&gt;&lt;/ul&gt;&lt;div class=&quot;img-preview&quot;&gt;&lt;/div&gt;&lt;script&gt;//todo ...&lt;/script&gt; 实现：123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JS Bin&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul class=&quot;ct&quot;&gt; &lt;li data-img=&quot;http://img3.imgtn.bdimg.com/it/u=2744235171,1121575194&amp;fm=21&amp;gp=0.jpg&quot;&gt;鼠标放置查看图片1&lt;/li&gt; &lt;li data-img=&quot;http://img3.imgtn.bdimg.com/it/u=954554677,3720466482&amp;fm=21&amp;gp=0.jpg&quot;&gt;鼠标放置查看图片2&lt;/li&gt; &lt;li data-img=&quot;http://img0.imgtn.bdimg.com/it/u=2657893920,4044129460&amp;fm=21&amp;gp=0.jpg&quot;&gt;鼠标放置查看图片3&lt;/li&gt;&lt;/ul&gt;&lt;div class=&quot;img-preview&quot;&gt;&lt;/div&gt;&lt;script&gt; var ct=document.querySelector(&apos;.ct&apos;); var imgPre=document.querySelector(&apos;.img-preview&apos;); var li=document.querySelectorAll(&apos;li&apos;); // for(var i=0;i&lt;li.length;i++)&#123; // li[i].addEventListener(&apos;mouseover&apos;,function()&#123; // var data=this.getAttribute(&apos;data-img&apos;); // console.log(data); // imgPre.innerHTML=&apos;&lt;img src=&quot;&apos; + data + &apos;&quot;&gt;&apos;; // &#125;); // &#125; ct.addEventListener(&apos;mouseover&apos;,function(e)&#123; var data=e.target.getAttribute(&apos;data-img&apos;); if(data)&#123; imgPre.innerHTML=&apos;&lt;img src=&quot;&apos;+data+&apos;&quot;&gt;&apos;; &#125; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; JSbin 实现如下图Tab切换的功能123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JS Bin&lt;/title&gt; &lt;style&gt; ul,li&#123; list-style:none; margin:0; padding:0; &#125; .clearfix:after&#123; content:&apos;&apos;; display:block; clear:both; &#125; #tab&#123; box-sizing:border-box; border:1px solid lightgray; &#125; .nav&#123; border-bottom:1px solid lightgray; text-align: center; &#125; .nav li&#123; float:left; width:33.1%; height:30px; line-height:30px; border-left:1px solid lightgray; &#125; .nav .show&#123; background-color:lightgray; &#125; .content&#123; height:150px; display:none; &#125; #tab .show&#123; display:block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;tab&quot;&gt; &lt;ul class=&quot;nav clearfix&quot;&gt; &lt;li class=&apos;show&apos;&gt;tab1&lt;/li&gt; &lt;li&gt;tab2&lt;/li&gt; &lt;li&gt;tab3&lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;content show&quot;&gt;内容1&lt;/div&gt; &lt;div class=&quot;content&quot;&gt;内容2&lt;/div&gt; &lt;div class=&quot;content&quot;&gt;内容3&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var li=document.querySelectorAll(&apos;li&apos;); var nav=document.querySelector(&apos;.nav&apos;); var content=document.querySelectorAll(&apos;.content&apos;); nav.addEventListener(&apos;click&apos;,function(e)&#123; var target=e.target, libs=nav.children; for(var i=0;i&lt;li.length;i++)&#123; li[i].removeAttribute(&apos;class&apos;); &#125; target.setAttribute(&apos;class&apos;,&apos;show&apos;); var index=[].indexOf.call(li,target); var cls=content[index].getAttribute(&apos;class&apos;); for(i=0;i&lt;content.length;i++)&#123; content[i].setAttribute(&apos;class&apos;,&apos;content&apos;); &#125; content[index].setAttribute(&apos;class&apos;,cls+&apos; show&apos;); &#125;); &lt;/script&gt;&lt;/body&gt; JSbin 实现下图的模态框功能实现：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JS Bin&lt;/title&gt; &lt;style&gt; a&#123; text-decoration: none; color:black; &#125; h3&#123; margin: 0px; padding:0px; &#125; .clearfix:after&#123; content: &apos;&apos;; display: block; clear: both; &#125; .modal-dialog&#123; display: none; &#125; .dialog&#123; position:relative; top: 347px; left: 38%; width: 100%; height: 100%; &#125; .header,.content,.footer&#123; width:500px; border:1px solid lightgray; padding: 10px; background-color: white; &#125; .footer&#123; text-align: right; &#125; .header h3&#123; float: left; &#125; .header .close&#123; float: right; &#125; .cover&#123; position: fixed; width: 100%; height: 100%; background-color: #000; top: 0; left: 0; opacity: 0.4; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;button class=&quot;btn-modal&quot;&gt;点我&lt;/button&gt; &lt;div class=&quot;modal-dialog&quot;&gt; &lt;div class=&quot;cover&quot;&gt;&lt;/div&gt; &lt;div class=&quot;dialog&quot;&gt; &lt;div class=&quot;header clearfix&quot;&gt; &lt;h3&gt;我是标题&lt;/h3&gt; &lt;a href=&quot;#&quot; class=&quot;close&quot;&gt;X&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;content&quot;&gt; &lt;p&gt;我是内容1&lt;/p&gt; &lt;p&gt;我是内容2&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;footer&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;btn-cancle&quot;&gt;取消&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;btn&quot;&gt;确定&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var btnModal=document.querySelector(&apos;.btn-modal&apos;); var modalDialog=document.querySelector(&apos;.modal-dialog&apos;); var dialog=document.querySelector(&apos;.dialog&apos;); btnModal.addEventListener(&apos;click&apos;,function(e)&#123; modalDialog.style.display=&apos;block&apos;; e.stopPropagation(); &#125;) document.body.addEventListener(&apos;click&apos;,function()&#123; modalDialog.style.display=&apos;none&apos;; &#125;) dialog.addEventListener(&apos;click&apos;,function(e)&#123; e.stopPropagation(); if (e.target.getAttribute(&apos;class&apos;)===&apos;close&apos;||e.target.getAttribute(&apos;class&apos;)===&apos;btn-cancle&apos;) &#123; modalDialog.style.display=&apos;none&apos;; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; JSbin","tags":[]},{"title":"浏览器兼容","date":"2016-08-25T16:00:00.000Z","path":"2016/08/26/浏览器兼容-1/","text":"前面内容我们可以看到，在不同的浏览器下，添加和移除事件处理程序方式不相同，要想写出跨浏览器的事件处理程序，首先我们要了解不同的浏览器下处理事件处理程序的区别 在添加事件处理程序事addEventListener和attachEvent主要有几个区别 参数个数不相同，这个最直观，addEventListener有三个参数，attachEvent只有两个，attachEvent添加的事件处理程序只能发生在冒泡阶段，addEventListener第三个参数可以决定添加的事件处理程序是在捕获阶段还是冒泡阶段处理（我们一般为了浏览器兼容性都设置为冒泡阶段） 第一个参数意义不同，addEventListener第一个参数是事件类型（比如click，load），而attachEvent第一个参数指明的是事件处理函数名称（onclick，onload） 事件处理程序的作用域不相同，addEventListener的作用域是元素本身，this是指的触发元素，而attachEvent事件处理程序会在全局变量内运行，this是window，所以刚才例子才会返回undefined，而不是元素id 为一个事件添加多个事件处理程序时，执行顺序不同，addEventListener添加会按照添加顺序执行，而attachEvent添加多个事件处理程序时顺序无规律(添加的方法少的时候大多是按添加顺序的反顺序执行的，但是添加的多了就无规律了)，所以添加多个的时候，不依赖执行顺序的还好，若是依赖于函数执行顺序，最好自己处理，不要指望浏览器 了解了这四点区别后我们可以尝试写一个浏览器兼容性比较好的添加事件处理程序方法123456789101112function addEvent(node, type, handler) &#123; if (!node) return false; if (node.addEventListener) &#123; node.addEventListener(type, handler, false); return true; &#125; else if (node.attachEvent) &#123; node.attachEvent(&apos;on&apos; + type, handler, ); return true; &#125; return false;&#125; 这样，首先我们解决了第一个问题参数个数不同，现在三个参数，采用事件冒泡阶段触发 第二个问题也得以解决，如果是IE，我们给type添加上on 第四个问题目前还没有解决方案，需要用户自己注意，一般情况下，大家也不会添加很多事件处理程序 试试这个方法感觉很不错，但是我们没有解决第三个问题，由于处理程序作用域不同，如果handler内有this之类操作，那么就会出错。在IE下，实际上大多数函数都会有this操作123456789101112function addEvent(node, type, handler) &#123; if (!node) return false; if (node.addEventListener) &#123; node.addEventListener(type, handler, false); return true; &#125; else if (node.attachEvent) &#123; node.attachEvent(&apos;on&apos; + type, function() &#123; handler.apply(node); &#125;); return true; &#125; return false;&#125; 这样处理就可以解决this的问题了，但是新的问题又来了，我们这样等于添加了一个匿名的事件处理程序，无法用detachEvent取消事件处理程序，有很多解决方案，我们可以借鉴大师的处理方式，jQuery创始人John Resig是这样做的12345678910111213141516function addEvent(node, type, handler) &#123; if (!node) return false; if (node.addEventListener) &#123; node.addEventListener(type, handler, false); return true; &#125; else if (node.attachEvent) &#123; node[&apos;e&apos; + type + handler] = handler; node[type + handler] = function() &#123; node[&apos;e&apos; + type + handler](window.event); &#125;; node.attachEvent(&apos;on&apos; + type, node[type + handler]); return true; &#125; return false;&#125; 在取消事件处理程序的时候123456789101112function removeEvent(node, type, handler) &#123; if (!node) return false; if (node.removeEventListener) &#123; node.removeEventListener(type, handler, false); return true; &#125; else if (node.detachEvent) &#123; node.detachEvent(&apos;on&apos; + type, node[type + handler]); node[type + handler] = null; &#125; return false;&#125; John Resig很巧妙地利用了闭包，看起来很不错。 完整兼容封装123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566function $$(el)&#123; if(el.length &lt; 1)&#123; return; &#125; var sub = el.substring(1); if( el[0] === &apos;#&apos;)&#123; return document.getElementById(sub); &#125;else if(el[0] === &apos;.&apos;)&#123; return document.getElementsByClassName(sub); &#125;else&#123; return document.getElementsByTagName(el); &#125;&#125;function addEvent(node, type, handler) &#123; if (!node) return false; if (node.addEventListener) &#123; node.addEventListener(type, handler, false); return true; &#125; else if (node.attachEvent) &#123; node[&apos;e&apos; + type + handler] = handler; node[type + handler] = function() &#123; node[&apos;e&apos; + type + handler](window.event); &#125;; node.attachEvent(&apos;on&apos; + type, node[type + handler]); return true; &#125; return false;&#125;function removeEvent(node, type, handler) &#123; if (!node) return false; if (node.removeEventListener) &#123; node.removeEventListener(type, handler, false); return true; &#125; else if (node.detachEvent) &#123; node.detachEvent(&apos;on&apos; + type, node[type + handler]); node[type + handler] = null; &#125; return false;&#125;function getEvent(e) &#123; return e || window.event;&#125;function getTarget(e) &#123; return e.target || e.scrElement;&#125;function preventDefault(e) &#123; if (e.preventDefault) e.preventDefault(); else e.returnValue = false;&#125;function stopPropagation(e) &#123; if (e.stopPropagation) e.stopPropagation(); else e.cancelBubble = true;&#125;","tags":[]},{"title":"正则表达式","date":"2016-08-23T16:00:00.000Z","path":"2016/08/24/正则表达式/","text":"\\d，\\w,\\s,[a-zA-Z0-9],\\b,.,*,+,?,x{3},^、$分别是什么?\\d：查找数字\\w：查找单词字符（数字、字符、下划线）\\s：查找空白字符（空格、tab、换行、回车符）[a-zA-Z0-9]：查找a~z、A~Z、0-9\\b：匹配单词边界.：查找任意字符，除了换行和行结束符*：匹配零个或多个的字符串+：匹配至少一个字符串?：匹配零个或一个字符x{3}：匹配包含X个n的序列的字符串^：匹配开头的字符串$：匹配结尾字符 贪婪模式和非贪婪模式指什么?贪婪模式：正则引擎尽可能的重复匹配字符非贪婪模式：正则引擎进坑能少的匹配字符 代码题 写一个函数trim(str)，去除字符串两边的空白字符 123function trim(str)&#123; return str.replace(/^\\s+|\\s+$/g,&apos;&apos;)&#125; 使用实现 addClass(el, cls)、hasClass(el, cls)、removeClass(el,cls)，使用正则ps： 视频里问题纠正//提示: el为dom元素，cls为操作的class， el.className获取el元素的class 1234567891011121314function hasClass(el,cls)&#123; var reg=new RegExp(&apos;(\\\\s|^)&apos;+cls+&apos;(\\\\b|$)&apos;,&apos;g&apos;); return reg.test(el.className);&#125;function addClass(el,cls)&#123; if(!hasClass(el,cls)) return el.className+&apos; &apos;+cls;&#125;function removeClass(el,cls)&#123; if (hasClass(el,cls) )&#123; var reg = new RegExp(&apos;(\\\\s|^)&apos;+ cls +&apos;(\\\\s|$)&apos;); return el.className.replace(reg,&apos;&apos;); &#125;&#125; 写一个函数isEmail(str)，判断用户输入的是不是邮箱 1234567function isEmail(str)&#123; var ptta=/^[\\w_]+@[\\w]+\\.[\\w]+/; if(str.search(ptta)&gt;-1)&#123; return true; &#125; return false;&#125; 写一个函数isPhoneNum(str)，判断用户输入的是不是手机号 1234function isPhoneNum(str)&#123; var reg=/^1[345789][0-9]&#123;9&#125;/; return reg.test(str);&#125; 写一个函数isValidUsername(str)，判断用户输入的是不是合法的用户名（长度6-20个字符，只能包括字母、数字、下划线） 1234function isValidUsername(str)&#123; var reg=/^\\w&#123;6,20&#125;$/; return reg.test(str);&#125; 写一个函数isValidPassword(str), 判断用户输入的是不是合法密码（长度6-20个字符，包括大写字母、小写字母、数字、下划线至少两种） 1234567891011121314151617181920function isValidPassword(str)&#123; var reg=/^\\w&#123;6,20&#125;$/; if(!reg.test(str))&#123; return false; &#125; var i=0; if(/\\d/.test(str)) i++; if(/[a-z]/.test(str)) i++; if(/[A-Z]/.test(str)) i++; if(/_/.test(str)) i++; if(i&gt;=2)&#123; return true; &#125;else&#123; return false; &#125;&#125; 写一个正则表达式，得到如下字符串里所有的颜色（#121212） 123var re = /*正则...*/var subj = &quot;color: #121212; background-color: #AA00ef; width: 12px; bad-colors: f#fddee #fd2 &quot;alert( subj.match(re) ) // #121212,#AA00ef 1`var re =/#[0-9a-fA-F]&#123;6&#125;/g;` 下面代码输出什么? 为什么? 改写代码，让其输出hunger, world.12345var str = &apos;hello &quot;hunger&quot; , hello &quot;world&quot;&apos;;var pat = /&quot;.*&quot;/g;str.match(pat);//输出 [&quot;\\&quot;hunger\\&quot; , hello \\&quot;world\\&quot;&quot;]//贪婪模式下会尽可能多的匹配字符串 12//采用非贪婪模式var pat=/&quot;.*?&quot;/g 补全如下正则表达式，输出字符串中的注释内容. (可尝试使用贪婪模式和非贪婪模式两种方法)123str = &apos;.. &lt;!-- My -- comment \\n test --&gt; .. &lt;!----&gt; .. &apos;re = /.. your regexp ../str.match(re) // &apos;&lt;!-- My -- comment \\n test --&gt;&apos;, &apos;&lt;!----&gt;&apos; 12//非贪婪模式re = /&lt;[\\w\\W]*?&gt;/g; 12//贪婪模式re = /&lt;[^&lt;]+&gt;/g; 补全如下正则表达式123var re = /* your regexp */var str = &apos;&lt;&gt; &lt;a href=&quot;/&quot;&gt; &lt;input type=&quot;radio&quot; checked&gt; &lt;b&gt;&apos;str.match(re) // &apos;&lt;a href=&quot;/&quot;&gt;&apos;, &apos;&lt;input type=&quot;radio&quot; checked&gt;&apos;, &apos;&lt;b&gt;&apos; 1var re= /&lt;[^&lt;]+&gt;/g;","tags":[]},{"title":"闭包、定时器","date":"2016-08-20T16:00:00.000Z","path":"2016/08/21/闭包、定时器/","text":"什么是闭包? 有什么作用首先需要理解Javascript特殊的变量作用域，即全局变量和局部变量。在函数内部可以直接读取全局变量，在函数外部自然无法读取函数内的全局变量。 闭包则是指有权访问另一个函数作用域中的变量的函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数，并且返回，就可以访问函数内部变量。123456789 function f1()&#123; var n=999; function f2()&#123; alert(n); &#125; return f2; &#125; var result=f1(); result(); // 999 闭包与变量 闭包保存的是整个变量对象，而不是某个特殊的变量，闭包只能取得包含函数中任何变量的最后一个值。 闭包与this 我们都知道，this对象是在运行时基于函数的执行环境绑定的：在全局函数中，this等于window，而当函数被作为某个对象的方法调用时，this等于那个对象。不过匿名函数的执行环境具有全局性，因此this对象通常指向window。 12345678910var name = &quot;The Window&quot;; var object = &#123; name : &quot;My Object&quot;, getNameFunc : function()&#123; return function()&#123; return this.name; &#125;; &#125; &#125;; alert(object.getNameFunc()());//The Window 在特殊情况下，this的值可能发生改变，比如： 1234567891011var name = &quot;The Window&quot;;var obfect = &#123; name : &quot;My Object&quot;, getName : function()&#123; return this.name; &#125;&#125;object.getName(); //&quot;My Object&quot;(object.getName)() //&quot;My Object&quot;(object.getName = object.getName)(); //&quot;The Window&quot; setTimeout 0 有什么作用 setTimeout是一个延时函数，当设定延迟的时间为0时，会使setTimeout内部的函数在所有要执行的js语句执行完成之后再执行。12345console.log(1);;setTimeout(function()&#123; console.log(2);&#125;,0)console.log(3); 代码 下面的代码输出多少？修改代码让fnArri 输出 i。使用两种以上的方法1234567var fnArr = []; for (var i = 0; i &lt; 10; i ++) &#123; fnArr[i] = function()&#123; return i; &#125;; &#125; console.log( fnArr[3]() ); //10 1.立即执行函数传参123456789var fnArr = [];for(var i=0;i&lt;10;i++)&#123; (function(n)&#123; fnArr[i]=function()&#123; return n; &#125; &#125;)(i)&#125;console.log( fnArr[3]() ); //10 2.立即执行函数，临时变量保存变量123456789var fnArr = [];for(var i=0;i&lt;10;i++)&#123; (function()&#123; var n=i; fnArr[i]=function()&#123; return n; &#125; &#125;)()&#125; 3.函数内部返回函数，传参12345678var fnArr = [];for(var i=0;i&lt;10;i++)&#123; fnArr[i]=(function(n)&#123; return function()&#123; return n; &#125; &#125;)(i)&#125; 4.函数内部返回函数，临时变量保存参数123456789var fnArr = [];for(var i=0;i&lt;10;i++)&#123; fnArr[i]=(function()&#123; var n=i; return function()&#123; return n; &#125; &#125;)()&#125; 使用闭包封装一个汽车对象，可以通过如下方式获取汽车状态12345678910111213var Car = //todo;Car.setSpeed(30);Car.getSpeed(); //30Car.accelerate();Car.getSpeed(); //40;Car.decelerate();Car.decelerate();Car.getSpeed(); //20Car.getStatus(); // &apos;running&apos;;Car.decelerate();Car.decelerate();Car.getStatus(); //&apos;stop&apos;;//Car.speed; //error 1234567891011121314151617181920212223242526272829var Car = (function()&#123; var speed=0; function setSpeed(n)&#123; speed=n; &#125; function getSpeed()&#123; console.log(speed); &#125; function accelerate()&#123; speed+=10; &#125; function decelerate()&#123; speed-=10; &#125; function getStatus()&#123; if(speed&gt;0)&#123; console.log(&apos;running&apos;); &#125;else&#123; console.log(&apos;stop&apos;); &#125; &#125; return &#123; setSpeed:setSpeed, getSpeed:getSpeed, accelerate:accelerate, decelerate:decelerate, getStatus:getStatus &#125;;&#125;)(); 写一个函数使用setTimeout模拟setInterval的功能 1234567var i=0;function intv()&#123; setTimeout(function()&#123; console.log(++i); intv(); &#125;,1000)&#125; 写一个函数，计算setTimeout平均[备注：新加]最小时间粒度 12345678910111213function getMini()&#123; var i=0; var start=Date.now(); var clock=setTimeout(function()&#123; i++; if(i===1000)&#123; var end=Date.now(); console.log((end-start)/i); clearTimeout(clock); &#125; clock=setTimeout(arguments.callee,0); &#125;,0);&#125; 下面这段代码输出结果是? 为什么? 12345678910var a = 1;setTimeout(function()&#123; a = 2; console.log(a);&#125;, 0);var a ;console.log(a);a = 3;console.log(a);//1 3 2 setTimeout 0 使内部函数延迟执行，放在所有函数的最后面 下面这段代码输出结果是? 为什么? 1234567var flag = true;setTimeout(function()&#123; flag = false;&#125;,0)while(flag)&#123;&#125;console.log(flag);//死循环，setTimeout使内部函数在所有的函数队尾执行，flag一直为真，所以死循环 下面这段代码输出？如何输出delayer: 0, delayer:1…（使用闭包来实现） 1234567for(var i=0;i&lt;5;i++)&#123; setTimeout(function()&#123; console.log(&apos;delayer:&apos; + i ); &#125;, 0); console.log(i);&#125;//输出0,1,2,3,4 五个delayer:5 123456for(var i=0;i&lt;5;i++)&#123; setTimeout((function(n)&#123; console.log(&apos;delayer:&apos; + i ); &#125;)(i), 0); console.log(i);&#125;","tags":[]},{"title":"时间对象、引用类型","date":"2016-08-15T16:00:00.000Z","path":"2016/08/16/时间对象、引用类型/","text":"基础类型有哪些？复杂类型有哪些？有什么特征？ 基础类型：有数值、布尔值、null和undefined。保存在栈内存中的简单数据段 复杂类型：有对象、函数、正则、数组。保存在堆内存中的对象，变量中保存的实际上是一个指针，这个指针指向内存中的另一个位置，由该位置保存对象。 如下代码的输出? 为什么?12345var obj1 = &#123;a:1, b:2&#125;;var obj2 = &#123;a:1, b:2&#125;;console.log(obj1 == obj2);//false。obj1,obj2保存的是地址，即使内容一样，也不相同console.log(obj1 = obj2);//object&#123;a:1,b:2&#125;。将obj2里的地址赋值给obj1console.log(obj1 == obj2);//true。已经进行了赋值，所以obj2和obj1相等 代码在线预览","tags":[]},{"title":"数组、字符串、数学函数","date":"2016-08-15T16:00:00.000Z","path":"2016/08/16/数组、字符串、数学函数/","text":"数组方法里push、pop、shift、unshift、join、split分别是什么作用。push：从数组队尾添加元素，返回数组长度pop：从数组队尾弹出元素，返回被弹出的值shift：从数组的队头弹出元素，返回被弹出的值unshift：从数组的队头添加元素，返回数组长度join：把数组内容拼接成字符串，返回一个新的数组split：把字符串分割成数组,返回一个数组 代码在线预览","tags":[]},{"title":"函数","date":"2016-08-11T16:00:00.000Z","path":"2016/08/12/函数/","text":"函数声明和函数表达式有什么区别 函数声明 12345function add(num1,num2)&#123; var sum = 0; sum = num1+num2; return sum;&#125; 函数表达式 12345var add= function (num1,num2)&#123; var sum = 0; sum = num1+num2; return sum;&#125;; 函数声明和函数表达式的区别： 函数声明必须给定函数名称，函数表达式则可以忽略名称； 函数声明是整体的声明提前，而函数表达式则是函数变量的声明提前； 什么是变量的声明前置？什么是函数的声明前置？变量的声明前置就是把变量的声明提升到当前作用域的最前面12345678console.log(a);var a = 1;/*等价于var a;console.log(a);a = 1;*/ 函数声明前置就是把函数声明提升到当前作用域的前面，位于变量声明前置之后。123456789101112131415161718add(1,2);function add(num1,num2)&#123; var sum = 0; sum = num1+num2; return sum;&#125;var a = 1;/*等价于var a;function add(num1,num2)&#123; var sum = 0; sum = num1+num2; return sum;&#125;add(1,2);a = 1;*/ 这里需要注意函数声明前置和函数表达式声明前置的区别。 arguments 是什么arguments是一个函数自带的存储参数的类数组对象。arguments的值由函数的传入参数有关，与函数定义参数无关。 函数的重载怎样实现函数的重载：声明几个相同名称的函数，通过传入不同的形参，以达到用同一操作符进行不同运算的功能。重载函数通常用来实现功能类似而所处理的数据类型不同的问题。而在JavaScript中定义同名的函数只会达到覆盖的效果，没法利用函数的形参不同而达到函数重载的目的，这时候可以利用arguments来达到函数重载的目的。1234567fouction add()&#123; var sum = 0; for(var i = 0;i&lt;arguments.length;i++)&#123; sum += arguments[i]; console.log(sum); &#125;&#125; 立即执行函数表达式是什么？有什么作用123(function () &#123; alert(&apos;watch out!&apos;); &#125;()); 立即执行函数是为了达到立即调用函数的效果。立即执行函数表达式的作用： 可以创建匿名函数，避免污染全局变量 形成一个单独的作用域，可以达到进行封装的效果。 什么是函数的作用域链作用域：变量和函数的可访问范围，控制变量的可见性和声明周期。分为全局作用域和局部作用域。 全局作用域：变量没有用var声明时即为全局变量，拥有全局作用域，在代码任何地方都可以访问。 局部作用域：函数内部用var声明的变量就是局部变量，只能在函数体内使用，函数的参数也是局部变量。 作用域链：当代码在一个环境中执行时，会创建变量对象的一个作用域链来保证对执行环境有权访问的变量和函数的有序访问。作用域第一个对象始终是当前执行代码所在环境的变量对象。1234function a(x,y)&#123; var b=x+y; return b; &#125; 而当函数执行时，那么函数对象则会创建一个活动对象作为函数作用域链的第一个对象，第二个环境是上一层的包含环境，一直到全局作用域为止。 代码 以下代码输出什么？ 123456789101112131415161718192021222324252627282930313233 function getInfo(name, age, sex)&#123; console.log(&apos;name:&apos;,name); console.log(&apos;age:&apos;, age); console.log(&apos;sex:&apos;, sex); console.log(arguments); arguments[0] = &apos;valley&apos;; console.log(&apos;name:&apos;, name); &#125; getInfo(&apos;hunger&apos;, 28, &apos;男&apos;);/* name:hunger age:28 sex:男 [&apos;hunger&apos;,&apos;28&apos;,&apos;男&apos;] name:valley*/ getInfo(&apos;hunger&apos;, 28);/* name:hunger age:28 sex:undefined [&apos;hunger&apos;,&apos;28&apos;] name:valley*/ getInfo(&apos;男&apos;);/* name:男 age:undefined sex:undefined [&apos;男&apos;] name:valley*/ 写一个函数，返回参数的平方和？ 1234function sumOfSquares()&#123; &#125; sumOfSquares(2,3,4); // 29 sumOfSquares(1,3); // 10 123456789function sumOfSquares()&#123; var sum=0; for(var i=0;i &lt; arguments.length;i++)&#123; sum += arguments[i]*arguments[i]; &#125; document.write(sum+&quot; &quot;);&#125;sumOfSquares(2,3,4); // 29sumOfSquares(1,3); // 10 JsBin 如下代码的输出？为什么 123console.log(a); //undefined 声明提前 var a; 被提到最前面var a = 1;console.log(b); // 报错，因为变量b没有声明 如下代码的输出？为什么 12345678sayName(&apos;world&apos;); //hello world;函数声明整体提前 sayAge(10);//报错 sayAge不是函数类型；因为函数变量提前而不会整体提前 function sayName(name)&#123; console.log(&apos;hello &apos;, name); &#125; var sayAge = function(age)&#123; console.log(age); &#125;; 如下代码的输出？为什么 12345678910 function fn()&#123;&#125; var fn = 3; console.log(fn); //3/*等价于var fn;function fn()&#123;&#125;;fn = 3;console.log(fn);*/ 如下代码的输出？为什么 12345678910111213 function fn(fn2)&#123; console.log(fn2); var fn2 = 3; console.log(fn2); console.log(fn); function fn2()&#123; console.log(&apos;fnnn2&apos;); &#125; &#125; fn(10);//function//3//function 123456789101112等价于function fn(fn2)&#123; var fn2; function fn2()&#123; console.log(&apos;fnnn2&apos;); &#125; console.log(fn2); fn2 = 3; console.long(fn2); console.log(fn);&#125;fn(10); 如下代码的输出？为什么 12345var fn = 1; function fn(fn)&#123; console.log(fn); &#125; console.log(fn(fn)); //报错 fn现在被赋值为1 不是函数类型 等价于123456var fn;function fn(fn)&#123; console.log(fn);&#125;fn = 1;console.log(fn(fn)); 如下代码的输出？为什么 123456789101112/*声明提前var i;var j*/ console.log(j); //undefined console.log(i); //undefined for(var i=0; i&lt;10; i++)&#123; var j = 100; &#125; console.log(i); //10 console.log(j); //100 如下代码的输出？为什么 12345678910111213141516171819 fn(); var i = 10; var fn = 20; console.log(i); function fn()&#123; console.log(i); var i = 99; fn2(); console.log(i); function fn2()&#123; i = 100; &#125; &#125;/*输出undefined10010*/ 等价于12345678910111213141516var i;var fn; function fn()&#123; var i; function fn2()&#123; i = 100; &#125; console.log(i); i = 99; fn2(); console.log(i);&#125;fn();i = 10;fn = 20;console.log(i); 如下代码的输出？为什么 1234567var say = 0;(function say(n)&#123; console.log(n); if(n&lt;3) return; say(n-1); //递归函数&#125;( 10 ));//立即执行函数 执行完后销毁console.log(say); //say 为全局变量 输出 10 9 8 7 6 5 4 3 2 0","tags":[]},{"title":"JS语法","date":"2016-08-09T16:00:00.000Z","path":"2016/08/10/JS语法/","text":"CSS和JS在网页中的放置顺序是怎样的？ 对于CSS，应该使用&lt;link&gt;标签放在&lt;head&gt;标签内，当直接写在html文档中时应该在&lt;head&gt;标签内写一个&lt;style&gt;标签然后放在&lt;style&gt;标签内。 1234 /*CSS外部引用*/&lt;head&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;styles/index.css&quot;&gt;&lt;/head&gt; 12345678 /*内部样式表*/&lt;head&gt; &lt;style&gt; body&#123; margin:0; &#125; &lt;/style&gt;&lt;/head&gt; 对于JS通常放在&lt;body&gt;的内容的最后面，但是个别特殊JS内容应该尽量放在最前面。 1234 /*外部引用*/&lt;body&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;index.js&quot;&gt;&lt;/script&gt;&lt;/body&gt; 123456 /*内部引用*/&lt;body&gt; &lt;script&gt; alert(1); &lt;/script&gt;&lt;/body&gt; 解释白屏和FOUC 白屏问题：如果把样式放在底部，对于IE浏览器，在某些场景下页面会出现白屏，而不是内容逐步展现，如果使用@import标签，即使CSS放入&lt;link&gt;并且放在头部也可能出现白屏。在加载JS文件时，会警用并发，并阻止其他内容的下载，所以把JS放入页面顶部也会导致白屏现象。 FOUC无样式内容闪烁如果把样式放在底部,对于IE浏览器,在某些场景下(点击链接,输入URL,使用书签进入等),会出现 FOUC 现象(逐步加载无样式的内容,等CSS加载后页面突然展现样式).对于 Firefox 会一直表现出 FOUC . 将JS放在底部 脚本会阻塞后面内容的呈现 脚本会阻塞其后组建的下载 async和defer的作用是什么？有什么区别async和defer都时异步加载。没有defer或async，浏览器会立即加载并执行指定的脚本，立即指的是在渲染该&lt;script&gt;之下的文档元素之前，也就时说不等待后续载入的元素，读到就加载并执行。 有async，加载和渲染后续文档元素的过程将和script.js的加载与执行并行进行（异步）。 1&lt;script async type=&quot;text/javascript&quot; src=&quot;index.js&quot;&gt;&lt;/script&gt; 有defer，加载后续文档元素的过程将和script.js的加载并行进行，但 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。 defer和async的区别： defer：脚本延迟到文档解析和显示后执行，有顺序 async：不保证顺序 简述网页的渲染机制 浏览器打开页面时，先加载HTML的内容，然后解析HTML文件解析成DOM树。 解析CSS构建CSSOM树 把DOM和CSSOM组合成渲染树 在渲染树的基础上进行布局，计算每个节点的几何结构 把每个节点绘制到屏幕上 JavaScript 定义了几种数据类型? 哪些是简单类型?哪些是复杂类型? 简单类型 Number类型：整数和小数 String类型：字符组成的文本 Boolean类型：true和false的两个特定值 Null：表示已经定义了一个变量，但是目前没有赋值，即为空 Undefined类型：表示未定义或不存在 复杂类型Object类型 NaN、undefined、null分别代表什么? NaN表示非数字，但是属于Number类型。NaN和任何数值都不相等，包括它自己 undefined表示不存在值，就是此处目前不存在任何值。典型用法： 变量被声明了，但没有赋值时，就等于undefined 调用函数时，应该提供的参数没有提供，该参数等于undefined 对象没有复制的属性，该属性的值为undefined 函数没有返回值时，默认返回undefined null表示空值，即该处现在为空，用法： 作为函数的参数，表示该函数的参数是一个没有任何内容的对象 作为对象原型链的终点 typeof和instanceof的作用和区别?typeof和instanceof都能用来判断变量的类型或者是否为空。 typeof用以获取一个变量的类型，一半只能返回number,boolean,string,function,object,undefined类型。 而instaceof用来判断一个变量是否是某个对象的实例，返回值是布尔类型，已确定该变量是否为指定类型。 代码 完成如下代码判断一个变量是否是数字、字符串、布尔、函数1234567891011121314151617function isNumber(el)&#123;&#125;function isString(el)&#123;&#125;function isBoolean(el)&#123;&#125;function isFunction(el)&#123;&#125;var a = 2,b = &apos;jirengu&apos;,c = false;alert( isNumber(a) ); //truealert( isString(a) ); //falsealert( isString(b) ); //truealert( isBoolean(c) ); //truealert( isFunction(a)); //falsealert( isFunction( isNumber ) ); //true 代码预览 以下代码的输出结果是? 12345console.log(1+1); //2console.log(&quot;2&quot;+&quot;4&quot;); //24console.log(2+&quot;4&quot;); //24console.log(+new Date()); //1470814913028console.log(+&quot;4&quot;); //4 以下代码的输出结果是? 123var a = 1;a+++a; //3typeof a+2; //number2 遍历数组，把数组里的打印数组每一项的平方 123var arr = [3,4,5]// todo..// 输出 9, 16, 25 代码预览 遍历 JSON, 打印里面的值1234567var obj = &#123; name: &apos;hunger&apos;, sex: &apos;male&apos;, age: 28&#125;//todo ...// 输出 name: hunger, sex: male, age:28 代码预览 下面代码的输出是? 为什么1234console.log(a);//undefined 变量提升 a未赋值var a = 1;console.log(a); //1console.log(b); //b is undefined,未声明b","tags":[]},{"title":"浏览器兼容","date":"2016-07-21T16:00:00.000Z","path":"2016/07/22/浏览器兼容/","text":"如何调试 IE 浏览器F12调出开发者工具进行调试：高版本浏览器可以模拟低版本浏览器：但是对于更低版本的IE6和IE7因为不存在开发者工具，建议通过搭建虚拟器进行调试： 什么是CSS hack？在 CSS 和 HTML里如何写 hack？在 CSS 中 ie6、ie7的 hack 方式？由于不同厂商的浏览器，比如IE，Safari，Chrome等，或是同一浏览器的不同版本，对CSS的解析不同，因此会导致生成的页面效果不同，得不到想要的页面效果，这个时候就要针对不同的浏览器去写不同的CSS，让它同时兼容不同浏览器，能在不同的浏览器中也能得到我们想要的页面效果。简单说CSS hack目的就是使CSS代码兼容不同的浏览器。CSS和HTML中写hack：CSS hack大致有三种变现形式：CSS属性前缀法，选择器前缀法，以及IE条件注释法。 属性前缀法如，针对IE6的前缀hack：1234.main &#123; _color: black; -color: black;&#125; 针对IE7及以下的前缀hack：123456789101112131415161718192021.main &#123; !color: black; $color: black; &amp;color: black; *color: black; )color: black; =color: black; %color: black; +color: black; @color: black; ,color: black; .color: black; /color: black; `color: black; ]color: black; #color: black; ~color: black; ?color: black; :color: black; |color: black;&#125; 针对IE6~8的前缀hack：1234.main&#123; color: black\\9; color/*\\**/: black\\9;&#125; 选择器前缀法： 12* html .selector &#123;&#125;/*针对IE6*/*+html .selector &#123;&#125;/*针对IE7*/ 3.IE条件注释法：利用低版本IE无法识别注释的特性进行hack： 123456789101112131415&lt;!--[if IE 6]&gt;this is IE 6&lt;![end if]--&gt;&lt;!--[if IE 7]&gt;this is IE 7&lt;![end if]--&gt;&lt;!--[if IE 8]&gt;this is IE 8&lt;br/&gt;&lt;![end if]--&gt;&lt;!--[if IE 9]&gt;this is IE 9&lt;br/&gt;&lt;![end if]--&gt;&lt;!--[if !IE]--&gt;this is a good browser;&lt;!--&lt;![end if]--&gt; 参考：Browserhacks 列举几种 浏览器兼容问题 display:inline-block的兼容问题 12345.selector&#123; display:inline-block; *display:inline; *zoom:1;&#125; min-height兼容问题： 12345.selector&#123; min-height:100px; height:auto !important; height:100px;&#125; 透明度兼容问题： 123456.selector&#123; filter:alpha(opacity=50); -moz-opacity:0.5; -khtml-opacity: 0.5; opacity: 0.5;&#125; 针对兼容、多浏览器覆盖有什么看法？渐进增强和优雅降级是什么意思？要对使用人群进行调研，如果一个浏览器的使用人群低于5%则可以忽略该浏览器，因为要在所有浏览器实现同一效果是不现实的，并且针对一些低版本浏览器本身也存在一些无法解决的兼容bug，对于需要过多投入而无法得到相应回报的事情应该放弃。逐渐增强：对低版本浏览器进行设计，保证功能，然后在针对高浏览器进行效果等改进。优雅降级：直接对高版本浏览器进行完整功能设计，然后再进行低版本兼容。 reset.css和normalize.css分别是做什么的？为什么推荐使用normalize.css?reset.css是样式重置，以暴力方式覆盖掉浏览器的所有默认样式，以保持浏览器渲染的一致性。normalize.css则是一冲reset.css的代替方案，注重荣泳方案，重置掉该重置的样式，保留有用的user agent样式，同时进行一些bug修复。normalize.css的优点： 保护有用的浏览器默认样式，而不是完全去掉他们； 一般化的样式：为大部分HTML元素提供； 修复浏览器自身的bug，并保证个浏览器的一致性； 优化CSS可用性； 解释代码：用注释和详细的文档。 参考：来，让我们谈一谈Normalize IE盒模型和标准盒模型有什么区别? 怎样使 IE678使用标准盒模型?box-sizing:border-box有什么作用IE盒模型：宽度=边框+padding+内容宽度：标准盒模型：宽度= 内容宽度：添加&lt;!DOCTYPE html&gt;可以让IE678使用标准盒模型。box-sizing:border-box是CSS3新增属性，设置之后相当于以IE6模式解析盒模型 IE6,7,8下的盒模型，display:inline-block,max-width 盒模型：改变 padding和border之后的盒模型： display:inline-block:在IE8中，支持display:inline-block在不添加&lt;!DOCTYPE html&gt;声明时，则不支持display:inline-block:在IE7中，块级元素不支持display:inline-block,行内元素支持：IE6和IE7相同： max-width：IE8支持max-width属性：IE8在怪异模式下不支持：IE7支持max-width属性：在怪异模式下，IE7同样不支持该属性：IE6完全不支持该属性：","tags":[]},{"title":"负边距、三栏布局","date":"2016-07-18T16:00:00.000Z","path":"2016/07/19/负边距、三栏布局/","text":"负边距在让元素产生偏移时和position: relative有什么区别?负边距会让接下来挨着的元素也产生位置偏移：positioin:relative只会让元素本身发生位置偏移，接下来的元素不会发生影响： 使用负 margin 形成三栏布局有什么条件? 一个父元素和三个块级子元素。 父元素需要设置左右内边距 三个块级元素都需要设置浮动，并且固定宽度。 主要内容的块级元素需要设置在最上方，保证优先渲染，并且宽度设置为100%。 侧边栏设置负边距 圣杯布局的原理是怎样的? 简述实现圣杯布局的步骤圣杯布局指侧边栏定宽，中间自适应三栏布局。主内容放在前面优先渲染。 设置三栏式结构 设置侧边栏宽度，中间栏宽度，并设置浮动。并且根据侧边框宽度设置父元素内边距 设置左右侧边栏负边距，并利用positioin:relative设置侧边栏位置 双飞翼布局的原理? 实现步骤?双飞翼布局也是一个两边在父容器里固定宽度，中间自适应的布局。主内容放在前面优先渲染。 设置三栏式结构,主内容需要有父元素包裹 设置初始样式，主内容父元素宽度设置为100% 设置侧边栏负边距,以及根据侧边栏宽度设置主内容边距 代码github 用浮动、负边距实现如下效果代码一在线预览 使用圣杯布局实现如下三栏布局(两侧固定宽度200px,中间自适应)代码二在线预览 使用圣杯布局的思路实现如下两栏布局代码三在线预览4.使用双飞翼布局实现如下三栏布局(两侧固定宽度200px,中间自适应)代码四在线预览5.使用双飞翼布局的思路实现如下两栏布局代码五在线预览","tags":[]},{"title":"inline-block、BFC、边距合并","date":"2016-07-12T16:00:00.000Z","path":"2016/07/13/inline-block、BFC、边距合并/","text":"在什么场景下会出现外边距合并？如何合并？如何不让相邻元素外边距合并？给个父子外边距合并的范例同一文档流中的两个相邻块级元素会出现外边距合并。外边距合并会取margin的最大值。同级相邻块级元素合并：父子元素外边距合并，并且会合并成父元素外边距： 如何阻止相邻元素的外边距合并：阻止父子元素外边距合并： 通过设值父元素padding防止边距合并： 通过设置父元素border防止边距合并 防止兄弟元素边距合并，兄弟元素不会在水平方向上边距合并： 通过设置display:inline-block： 通过设置浮动： 把两个元素放在不同div中，再设置overflow属性： 去除inline-block内缝隙有哪几种常见方法? 通过更改书写方式： 通过设置负margin,但第一个li会溢出： 浮动： 父容器设置font-size:0： 父容器使用overflow: auto| hidden撑开高度的原理是什么？overflow:auto|hidden会触发bfc特性使其包裹浮动元素。 BFC是什么？如何形成BFC，有什么作用?BFC是一个独立布局环境，在BFC中的元素时不受外界元素影响的，并且在一个BFC中块盒和行盒都会垂直的沿着其父元素的边框排列，两个盒子之间的间隙是由他们的margin值决定的。浮动元素，绝对定位元素，固定定位元素，以及非块级盒子（如inline-block table-cell table-caption）和overflow值不为visable的块级盒子都会为他们创建新的BFC。这个特性可以用来消除浮动元素对其非浮动的兄弟元素和其子元素带来的影响，例如边距合并。 BFC参考 浮动导致的父容器高度塌陷指什么？为什么会产生？有几种解决方法元素设置浮动之后会脱离文档流，父元素会忽略浮动元素的存在，而且浮动元素会产生新的BFC，成为一个对立的布局环境不受其他元素影响，所以其父容器会产生高度塌陷。 解决方法：只要让容器形成新的BFC格式，就可以解决父容器高度塌陷问题。那个元素受影响了就设置那个元素属性主要方式有： 设置clear属性： 设置overflow属性： 其他方式：这些方式都会解决父元素塌陷问题，但是由于改变父容器属性会引发较多问题，所以常用的还是前两种。 以下代码每一行的作用是什么？ 为什么会产生作用？ 和BFC撑开空间有什么区别？12345678.clearfix:after&#123;/*给clearfix设置after伪类*/ content: &apos;&apos;;/*添加一个没内容的行内元素*/ display: block;/*把该元素设置为块级元素*/ clear: both;/*清除两边浮动*/&#125;.clearfix&#123; *zoom: 1;/*兼容IE6,7*/&#125; 在.clearfix的末尾添加一个伪元素，并将其设置为块级元素，并且清楚左右浮动，让父容器把塌陷空间撑开。BFC会让父元素变为一个独立空间，上述方法只是撑开内容。 代码Github代码一在线预览代码二在线预览","tags":[]},{"title":"浮动、定位","date":"2016-07-10T16:00:00.000Z","path":"2016/07/11/浮动、定位/","text":"文档流的概念指什么？有哪种方式可以让元素脱离文档流?将窗体自上而下分成一行行，并在每行中按从左至右的顺序排放元素，即为文档流。也就是文档中可显示对象在排列中所占用的位置，比如块级元素默认占据一行。浮动float以及定位中的绝对定位position:absolute和固定定位position:fixed都可以让元素脱离文档流。 有几种定位方式，分别是如何实现定位的，使用场景如何？ position:static：默认属性，没有设置定位的都是该定位，元素不会有特殊偏移位置。 position:relative：相对定位，相对于自己原来的位置进行定位，元素不会脱离文档流。 position:absolute：绝对定位，相对于父容器上拥有定位的元素位置定位，如果父级没有定位则逐级向上查找，元素脱离文档流。 position:fixed：固定定位，相对于浏览器窗口进行定位。 absolute, relative, fixed 偏移的参考点分别是什么position:relative：相对于自己原来的位置进行定位，元素不会脱离文档流。position:fixed：固定定位，相对于浏览器窗口进行定位。position:absolute：绝对定位，相对于父容器上拥有定位的元素位置定位，如果父级没有定位则逐级向上查找，元素脱离文档流。 z-index 有什么作用? 如何使用?z-index设置元素的堆叠属性，拥有更高堆叠顺序的元素总是会处在上面，该属性设置一个定位元素沿 z 轴的位置，z 轴定义为垂直延伸到显示区的轴。如果为正数，则离用户更近，为负数则表示离用户更远。只有在对元素进行了定位之后才可以设置元素的z-index属性。 position:relative和负margin都可以使元素位置发生偏移?二者有什么区别负margin就是把边距属性设置为负数，设置margin-bottom margin-right时元素本身不会发生位置偏移，设置margin-left margin-top时才会让元素发生位置偏移，但不管两种设置都会影响后面的元素。position:relative会让元素发生位置偏移，但是因为本身并没有脱离文档流，所以不会对后面的元素有影响。 如何让一个固定宽高的元素在页面上垂直水平居中?利用position:absolute，要设定居中的容器设置为绝对定位，然后调整top和left为50%，再设置margin为本身宽高的负一半。 浮动元素有什么特征？对其他浮动元素、普通元素、文字分别有什么影响?浮动框不在普通文档流中，所以文档中的块框就表现得像浮动框不存在一样。浮动框可以左右移动，直到碰到边缘或者下一个浮动框。1.框一像右浮动碰到边缘： 2.框一左浮动，框一因为脱离文档流，所以框二向上移动，框一盖住框二： 3.依次浮动： 4.在没有足够的水平空间时，元素会像下移动至空间足够： 浮动会让文字环绕浮动元素布局： 清除浮动指什么? 如何清除浮动?浮动带来各种遍历，而其脱离文档流的特性也会带来各种问题，例如元素环绕等，清除浮动就是来解决这些问题，清除浮动是针对元素本身，只对自己有效，不能影响别的元素。浮动引起的问题： 清楚浮动之后：清楚浮动的值：clear:none：默认值，允许两边都有浮动clear:left：不允许左边有浮动clear:right：不允许右边有浮动clear:both：两边都不允许有浮动 浮动和定位参考 代码一.写出如下两栏布局, 其中中间区块宽度900px, 居中,左侧边栏宽度200px, 右侧边栏宽度700pxps: 图片左浮动，导航栏整体右浮动，导航栏里面的li元素左浮动。ps: aside左浮动，main左浮动凡是有浮动的地方，其直接父元素必须清除浮动github在线预览二.不适用背景图片实现如下效果github在线预览","tags":[]},{"title":"CSS常见技巧","date":"2016-07-09T16:00:00.000Z","path":"2016/07/10/CSS常见技巧/","text":"CSS Sprite(雪碧图|精灵图)指什么? 有什么作用?CSS Sprite是指把多个icon合并成一张大图，然后利用css的背景定位来显示需要显示的图片部分，从而达到减少加载网页时对服务器的请求次数，提高页面的加载速度，减少鼠标滑过的一些bug等目的。12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .pig&#123; background: url(ps.png) 0 0 no-repeat; width: 45px; height: 45px; border:1px solid; &#125; .pig1&#123; background-position: 0px 0px; &#125; .pig2&#123; background-position: 0px -45px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;pig pig1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;pig pig2&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; img标签和CSS背景使用图片在使用场景上有何区别? &lt;img&gt;是HTML标签，是HTML结构的一部分。而CSS背景是CSS样式。 在网页加载过程中CSS背景会在网页结构完全加载完成之后才开始加载，&lt;img&gt;则会在家在过程中加载。 图片作为背景，如果加载失败，不会有图片的占位标记。 title 和 alt属性分别有什么作用alt属性是在不能显示图像，窗体或applets时的用户代理，用来指定替换文字。编辑代码时使用alt属性是为了那些不能看到你文档中的图像的浏览者提供文字说明。替换文字是用来替代图像而不是提供额外文字说明的。tilte属性为设置该属性的元素提供建议性信息。可以用在除了&lt;base&gt; &lt;basefont&gt; &lt;head&gt; &lt;html&gt; &lt;meta&gt; &lt;param&gt; &lt;script&gt; &lt;title&gt;之外的所有标签，但不是必须的。总结来说alt属性是在图片加载失败时的替换语音，性质为替代。title属性则是为表达一些额外信息，性质为一种备注或注释。 ###background: url(abc.png) 0 0 no-repeat;这句话是什么意思background的属性设置依次为：background-color：设置要使用的背景颜色background-image：设置要使用的背景图片background-repeat：设置如何重复背景图片background-attachment：设置背景图片是否固定或者随着页面其余部分滚动background-position：设置背景图片的位置，默认有两个值，如果只固定了一个值，则另一个值为50%inherit:设置从父元素继承background属性的设置所以题目的意思是把abc.png作为背景图片，位置为xpos0，ypos0，不重复绘制图片。123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .test&#123; background: url(1.jpg) 0 0; width: 500px; height: 500px; border: 1px solid; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;test&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; background-size有什么作用? 兼容性如何? 常用的值是?background-size指定背景图片的大小。常用的值：length：设置图片的高度和宽度。第一个值为宽度，第二个为高度，如果只设置一个值则第二个值为autopercentage：计算相对于背景定位区域的百分比。第一个值为宽度，第二个为高度，如果只设置一个值则第二个值为autocover：此时会保持图像的纵横比并将图像缩放成完全覆盖背景定位区域的最小大小。contain：此时会保持图像的纵横比并将图像缩放成将适合背景定位区域的最大大小。12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .test&#123; display: inline-block; background: url(1.jpg) 0 0 no-repeat; width: 300px; height: 300px; border: 1px solid; &#125; .jpg1&#123; background-size: 100px 100px; &#125; .jpg2&#123; background-size: 50% 50%; &#125; .jpg3&#123; background-size: cover; &#125; .jpg4&#123; background-size: contain; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;test jpg1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;test jpg2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;test jpg3&quot;&gt;&lt;/div&gt; &lt;div class=&quot;test jpg4&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 兼容性：IE9+, Firefox 4+, Opera, Chrome, 和 Safari 5+。 如何让一个div水平居中？如何让图片水平居中div水平居中：设置固定宽度，然后margin:0 auto图片居中：&lt;img&gt;是行内元素，所以只有在父级元素中设置text-algin:center就可以了。123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; div&#123; background-color:gray; width: 500px; border: 1px solid; margin:0 auto; text-align: center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; ![](1.jpg) &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 如何设置元素透明? 兼容性？透明有两种方法设置。rgba：rgba(red, green, blue, alpha)。opacity：0~1rgba兼容性： opacity兼容性： opacity和 rgba都能设置透明，有什么区别？opacity作用于元素以及元素内所有内容的透明度，而rgba只作用于元素的颜色或背景色12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .opacity&#123; display: inline-block; background-color:gray; width: 400px; height: 400px; opacity: 0.5; border: 1px solid; &#125; .rgba&#123; display: inline-block; background-color:rgba(192,192,192,0.5); width: 400px; height: 400px; border: 1px solid; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;opacity&quot;&gt; ![](1.jpg) 这是针对opacity属性的测试 &lt;/div&gt; &lt;div class=&quot;rgba&quot;&gt; ![](1.jpg) 这是针对rgba属性的测试 &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 代码题一.代码题一在线预览一二.代码题二在线预览二三.代码题三在线预览三","tags":[]},{"title":"CSS选择器","date":"2016-07-06T06:20:49.000Z","path":"2016/07/06/CSS选择器/","text":"CSS选择器常见的有几种?1.基础选择器 选择器 含义 * 通用选择器，匹配页面所有元素，很少使用 #id id选择器，匹配特定id的元素 .class 类选择器，匹配class包含特定类的元素 element 标签选择器，一般在reset时使用 2.组合选择器 选择器 含义 E,F 分组选择器，同时匹配E,F两个元素 E F 后代选择器，同时匹配E的后代中的所有F元素 E&gt;F 子元素选择器，匹配E元素的所有直接子元素 E+F 直接相邻选择器，匹配E元素之后的相邻同级元素F E~F 普通相邻选择器，匹配到E元素之后的同级元素F 3.属性选择器 选择器 含义 E[attr] 匹配所有具有属性attr的元素 E[attr=value] 匹配属性attr值为value的元素 E[attr~value] 匹配所有属性attr具有多个空格分隔、其中一个值等于value的元素 E[attr^=value] 匹配属性attr的值以value开头的元素 E[attr$=value] 匹配属性attr的值以value结尾的元素 E[attr*=value] 匹配属性attr的值包含value的元素 4.伪类选择器 选择器 含义 E:first-child 匹配元素E的第一个子元素 E:hover 匹配鼠标悬停其上的E元素 E:nth-child(n) 匹配其父元素的第n个子元素 E:last-child 匹配父元素的最后一个子元素 E:first-of-type 从一组中选择第一个元素 同级 选择孩子里面的第一个 E:[attr*=value] 从一组中选择最后一个 5.伪元素选择器 选择器 含义 E::first-line 匹配E元素内容的第一行 E::first-letter 匹配E元素内容的第一个字母 E::before 在E元素之前插入生成的内容 E::after 在E元素之后插入生成的内容 结合各类选择器可以实现一个自己的小型组件库： 选择器的优先级是怎样的? 在属性后面使用!important 作为style属性卸载元素标签的内联样式 id选择器 类选择器 伪类选择器 属性选择器 标签选择器 通配符选择器 浏览器自定义 在一些复杂的情况下，我们会依靠权重计算。id选择器的权值为1000，class选择器为100，标签选择器为10，如果两个选择器权值相同则后面的样式覆盖前面的样式。 class 和 id 的使用场景?class使用场景：默写需要特定样式的标签放在同一个class中，需要这一样式的标签则可以在标签上添加此类。id使用场景：根据提供的唯一id号，快速获取标签对象，用于充当label标签for属性的值。 使用CSS选择器时为什么要划定适当的命名空间？ 提高代码的可读性 便于管理维护 保持代码的拓展性 以下选择器分别是什么意思?123456789101112131415161718192021#header&#123; /*id选择器*/&#125;.header&#123; /*类选择器*/&#125;.header .logo&#123; /*类选择器.header的后类.logo*/&#125;.header.mobile&#123; /*同时满足.header和.mobile类*/&#125;.header p, .header h3&#123; /*.header中的标签p和.header中的标签h3*/&#125;#header .nav&gt;li&#123; /*id选择器header的后类选择器nav的直接子元素li*/&#125;#header a:hover&#123; /*id选择器header的后标签a的hover伪类*/&#125; 列出你知道的伪类选择器12345678910111213E:hoverE:activeE:linkE:visitedE:focusE:first-childE:first-of-typeE:nth-child(n)E:nth-of-type(n)E:last-childE:last-of-typeE:nth-last-child(n)E:nth-last-of-type(n) :first-child和:first-of-type的作用和区别?E:first-child和E:first-of-type的区别： first-child匹配的是某个父元素的第一个子元素，可以说是结构上的第一个子元素。 first-of-type匹配的是某父元素相同类型子元素的第一个，比如p:first-of-type，就是只所有类型为p的子元素的第一个，这里不再限制是第一个子元素了，只要是该类型元素的第一个就行了。 运行如下代码，解析下输出样式的原因。12345678910111213&lt;style&gt;.item1:first-child&#123; color: red;&#125;.item1:first-of-type&#123; background: blue;&#125;&lt;/style&gt; &lt;div class=&quot;ct&quot;&gt; &lt;p class=&quot;item1&quot;&gt;aa&lt;/p&gt; &lt;h3 class=&quot;item1&quot;&gt;bb&lt;/h3&gt; &lt;h3 class=&quot;item1&quot;&gt;ccc&lt;/h3&gt;&lt;/div&gt; 123.item1:first-child&#123; color: red;&#125; 这段代码的作用是.item1会根据父元素的伪类first-child选择第一个直接子元素，确定了第一个子元素&lt;p&gt;所以aa变成红色。123.item1:first-of-type&#123; background: blue;&#125; 这段代码.item1会根据父元素的伪类first-of-type选择相同类型的子元素，当遇见第一个标签&lt;p&gt;时，该标签是这一类元素的第一个子元素，所以其北京元素会编程蓝色。而遇到标签&lt;h3&gt;时，该标签又是该类标签的第一个子元素，所以其背景色也编程蓝色，而在往下的cc不是该组标签的第一个子元素，所以无变化。 text-align:center的作用是什么，作用在什么元素上？能让什么元素水平居中？作用是让内联元素对象在块级元素中居中，主要是让内联元素居中。在有固定宽度的块级元素中，也可以通过设置margin:0 auto让块级元素居中。 如果遇到一个属性想知道兼容性，在哪查看?在can i use中查看。","tags":[]},{"title":"盒模型","date":"2016-07-05T16:00:00.000Z","path":"2016/07/06/盒模型/","text":"盒模型包括那些属性文档中的元素被描绘为矩形盒子。每一个盒子有四个边界，分别为外边距边界，边框边界，内边距边界，内容边界。 内边距区域：是内容于边框之间可能有的空白区域。位于内边距边界内部，通常有背景，大小为padding-box宽与padding-box高。该区域可以有padding-top padding-left padding-right padding-bottom和简写属性padding控制。 边框区域：是包含边框的区域，位于边框界内部，大小为border-box的款和高。由border属性控制。 外边距区域：用空白区域扩展边框区域，用于分开相邻元素。它的大小为margin-box的宽高。该区域由margin-top margin-right margin-bottom margin-left或简写的margin控制。 内容区域：是真正包含元素内容的区域。 text-align: center的作用是什么，作用在什么元素上？能让什么元素水平居中作用是让文本内容以及内联元素对象在块级元素中居中，主要是让内联元素居中。在有固定宽度的块级元素中，也可以通过设置 margin:0 auto让块级元素居中。 IE 盒模型和W3C盒模型有什么区别?在ie678下ie怪异模式(不添加doctype说明)，使用ie盒模型，宽度=border+padding+内容宽度 在chrome，ie9，ie678(添加doctype)使用w3c盒模式，宽度=内容宽度 以下代码的作用？兼容性？123*&#123; box-sizing: border-box;&#125; box-sizing属性用来改变默认的盒模型对元素宽高的计算方式box-sizing:border-box：对width和height设置包括了元素的内边距与边框，不包括外边距，也就是ie的怪异模式。width=border+padding+内容宽度 height=border+padding+内容高度。box-sizing:content-box：对width和heigit的设置只包括内容的宽和高，不包括边框和内边距，也就是标准盒模式。浏览器兼容性： 代码github在线预览","tags":[]},{"title":"HTML4","date":"2016-07-04T16:00:00.000Z","path":"2016/07/05/HTML（4）/","text":"有序列表、无序列表、自定义列表如何使用？写个简单的例子。三者在语义上有什么区别？在哪些情况下使用哪种（重要）？ 如何嵌套？ 有序列表有顺序的列表，适用于有排列顺序的列表，如 12345&lt;ol class=&quot;getup&quot;&gt; &lt;li&gt;1.张开眼睛&lt;/li&gt; &lt;li&gt;2.抬起身子&lt;/li&gt; &lt;li&gt;3.穿衣服&lt;/li&gt;&lt;/ol&gt; 无序列表没有顺序的列表，也是最常使用的列表，如 12345&lt;ul class=&quot;food&quot;&gt; &lt;li&gt;包子&lt;/li&gt; &lt;li&gt;饺子&lt;/li&gt; &lt;li&gt;面条&lt;/li&gt;&lt;/ul&gt; 自定义列表自定义列表不仅仅是一列项目，也是项目及其注释的组合，如 123456&lt;dl&gt; &lt;dt&gt;包子&lt;/dt&gt; &lt;dd&gt;蒸着吃&lt;/dd&gt; &lt;dt&gt;饺子&lt;/dt&gt; &lt;dd&gt;煮着吃&lt;/dd&gt;&lt;/dl&gt; 具体选用那种列表就要根据自己的需要来决定，顺序列表在展示一些不能次序错乱的选项时是一个最佳的选择，无序列表则更适合表达一些并列的关系，自定义列表则更简单语义化。列表也可以嵌套使用，以达到更好的展示效果，如123456789101112131415161718&lt;dl&gt; &lt;dt&gt;必须干的事情&lt;/dt&gt; &lt;dd&gt; &lt;ol&gt; &lt;li&gt;1.起床&lt;/li&gt; &lt;li&gt;2.吃饭&lt;/li&gt; &lt;li&gt;3.睡觉&lt;/li&gt; &lt;/ol&gt; &lt;/dd&gt; &lt;dt&gt;选择要干的事情&lt;/dt&gt; &lt;dd&gt; &lt;ul&gt; &lt;li&gt;学习&lt;/li&gt; &lt;li&gt;运动&lt;/li&gt; &lt;li&gt;娱乐&lt;/li&gt; &lt;/ul&gt; &lt;/dd&gt;&lt;/dl&gt; 如何去除列表前面的点或者数字？使用list-style:none;可以去除。 class 和 id 有什么区别？什么时候用 class 什么时候用 id？ class和id的区别？class代表的是类，具有普遍性，可以被多次引用，可以应用到任何结构和内容上。class在页面布局上先定义好一类样式，然后根据页面需要把类样式应用到不用的元素和内容上。id具有唯一标识性，一般只在一个页面上使用一次，也可以重复定义，但是会被W3C认为不符合标准。id用于区分不同的内容和结构。id在页面布局上先确定结构和内容，再为它定义样式。 什么时候用 class 什么时候用 id？由于id的唯一性，一般用于定义单一的元素，或者需要程序JS控制的东西。class由于可以多次引用，一般在结构内部使用，用于定义重复使用的元素类别。 块级元素、行内元素是什么？有什么区别？分别对应哪些常用标签？ 块级元素、行内元素是什么？块级元素类似一个段落，是其他元素的容器。行内元素也叫内联元素或内嵌元素，只能容于文本内容或者其他行内元素。 有什么区别？1.块级元素会单独占据一整行，行内元素则只占用自身的内容宽度，可以并列显示。2.块级元素可以手动设置宽高。行内元素设置宽高是无效的，设置padding margin等在垂直方向不占空间，左右padding margin是有效的，我们可以根据line-height的特性为行内元素设置高度。 分别对应哪些常用标签？块级元素：&lt;div&gt; &lt;p&gt; &lt;dl&gt; &lt;ol&gt; &lt;ul&gt; &lt;li&gt; &lt;h1&gt;~&lt;h6&gt; &lt;table&gt;等行内元素:&lt;a&gt; &lt;span&gt; &lt;input&gt; &lt;img&gt; &lt;br&gt;等 display: block、display: inline、display: inline-block分别有什么作用?display:block:将元素设置为块级元素display:inline:将元素设置为行内元素display:inline-block:将对象呈递为内联元素，但是对象的内容作为块对象呈递。也就是说可以使元素在一行内呈现，并且可以设置宽高。 下面代码是做什么的？抄写一遍下面的代码，注意class和id的使用及命名方式123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;style&gt; .wrap&#123; width: 900px; margin: 0 auto; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;header&quot;&gt; &lt;div class=&quot;wrap&quot;&gt; &lt;a id=&quot;logo&quot; href=&quot;#&quot;&gt;&lt;img src=&quot;&quot;&gt;&lt;/a&gt; &lt;ul class=&quot;nav&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;导航1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;导航2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;导航3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;content&quot;&gt; &lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;aside&quot;&gt;侧边栏&lt;/div&gt; &lt;div class=&quot;main&quot;&gt;中心区块&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;div id=&quot;footer&quot;&gt; &lt;div class=&quot;wrap&quot;&gt;这里是 footer&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 把页面分成了头部，内容，底部三个部分，内容也分为了侧边栏和中心块区两部分。根据了区域的唯一性由id命名。在内部结构中，又因为样式相同并且要注意语义化，命名风格保持统一，用class设置了wrap类，设置了统一的宽度和边距。 如何理解 HTML CSS 语义化? 在平时写代码的过程中要注意哪些细节语义化是根据情况选择正确的标签，命名有含义并且保持统一的风格，便于阅读和维护 form表单有什么作用？有哪些常用的input 标签，分别有什么作用？form表单用于把用户数据提交到后台。&lt;input type=&quot;text&quot; name=&quot;user&quot; placeholder=&quot;用户名&quot; maxlength=10/&gt;用于输入文本&lt;input type=&quot;textarea&quot;&gt;文本域，用于文本框输入&lt;input type=&quot;password&quot;&gt;密码域，用于输入密码，内部文本以*显示&lt;input type=&quot;radio&quot;&gt;单选框&lt;input type=&quot;checkbox&quot;&gt;复选框&lt;input type=&quot;hidden&quot;&gt;隐藏域，用于暂存数据，安全校验&lt;input type=&quot;submit&quot;&gt;提交表单数据 post 和 get 方式的区别？ 数据提交方式不同，get会把提交的数据组织成url可以看到，post则在后台运行看不到。 get一般用于提交少量数据并获得大量数据，post一般提交大量数据得到少量信息。 get最多提交1k数据，post理论上不会有限制，受服务器限制。 get提交的数据会存在历史记录当中，安全性不好 在input里，name 有什么作用？name是表单提交时的名称，在提交时，后台会给对应的变量输入数据，&lt;input&gt;必须有那么属性。 在单选框中需要设定像同的name以保证是同一个单选框： 12&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;man&quot;/ checked&gt;男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;man&quot;/ checked&gt;女 在复选框中也可以把name设置成一个数组： 12&lt;input type=&quot;checkbox&quot; name=&quot;love&quot; value=&quot;运动&quot;/ checked&gt;运动&lt;input type=&quot;checkbox&quot; name=&quot;love&quot; value=&quot;吃&quot;/ checked&gt;吃 &lt;button&gt;提交&lt;/button&gt;，&lt;a class=&quot;btn&quot; href=&quot;#&quot;&gt;提交&lt;/a&gt;、&lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;三者有什么区别？&lt;button&gt;提交&lt;/button&gt;：普通按钮需要绑定JS事件&lt;a class=&quot;btn&quot; href=&quot;#&quot;&gt;提交&lt;/a&gt;：链接，点击后会跳转到页面，但是不会提交数据&lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;：用于提交表单数据 radio如何分组?用设置name来分组，如果name相同则为同一组，如果name不同则为不同组。12&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;man&quot;/ checked&gt;男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;man&quot;/ checked&gt;女 placeholder 属性有什么作用?用于设置提示信息&lt;input type=&quot;text&quot; name=&quot;user&quot; placeholder=&quot;用户名&quot; maxlength=10/&gt; type=hidden隐藏域有什么作用? 举例说明type=hidden用于暂存数据，安全校验123456&lt;form action=&quot;a.php&quot; method=&quot;post&quot;&gt; 账号：&lt;input type=&quot;text&quot; name=&quot;user&quot; placeholder=&quot;用户名&quot;/&gt;&lt;br/&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;请输入密码&quot;/&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;check&quot; value=&quot;666&quot;/&gt; &lt;/form&gt; 在后台会看到check的数据，以此校验安全性。 代码github地址在线预览","tags":[{"name":"html简介","slug":"html简介","permalink":"http://yoursite.com/tags/html简介/"}]},{"title":"HTML3","date":"2016-06-30T16:00:00.000Z","path":"2016/07/01/HTML（3）/","text":"一.line-height有什么作用?line-height是用于设置行高。并且在CSS中，有最底层的inline boxes起到检查行高度的作用，它会在行内元素中检查出高度最高的元素，并且把该高度作为整个行的高度。而line-height和height都起到高度作用，而在height没设置时，line-height则起到了高度设置的作用。line-height一个主要的作用就是设置文本垂直居中1.height和line-height都设置时：2.单独设置line-height时，则也会取到设置行高的作用：参考文档 二.如何去查CSS属性的兼容性？比如inline-block哪些浏览器支持？可以用Can I Use进行查询。inline-block所适用的浏览器： 三.&lt;a&gt;的href,title,target是什么？title和alt有什么区别？如何新窗口打开链接?1.&lt;a&gt;的href,title,target是什么？href规定链接的目标，&lt;a&gt;一定要设置该属性，否则鼠标移动到该链接只会以普通文本方式显示;title鼠标放在链接上时显示提示信息；target用来定义被链接的文档在何处显示；2.title和alt有什么区别？alt主要是为不能显示的图像，窗体提供文字信息，只能运用在&lt;img&gt;,&lt;area&gt;和&lt;input&gt;元素中。title可以提供非本质的额外信息，并且可以为链接添加描述性文字，可以用在除了&lt;base&gt;，&lt;basefont&gt;，&lt;head&gt;，&lt;html&gt;，&lt;meta&gt;，&lt;param&gt;，&lt;script&gt;和&lt;title&gt;之外的所有标签。3.如何新窗口打开链接?设置target=&quot;_blank&quot; 四.display: none, visibility: hidden, opacity:0有什么作用？有什么区别？display:none：会让元素消失，并且脱离文档流，但仍然存在在DOM树当中；visibility:hidden：让元素隐藏，不会脱离文档流；opacity:0：和visibility:hidden效果相同，不过可以设置透明度 五.如何去除 a 链接的默认样式？直接在 a 链接父容器添加颜色，能否继承到当前 a 链接上？可以通过设置text-decoration对链接样式进行设置。a链接不会继承父容器添加的颜色。 下面代码有什么作用？手抄一遍如下代码，改变浏览器宽度看看效果1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;style&gt; .wrap&#123; width: 900px; margin: 0 auto; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;header&quot;&gt; &lt;div class=&quot;wrap&quot;&gt;这里是标题&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;content&quot;&gt; &lt;div class=&quot;wrap&quot;&gt;这里是内容&lt;/div&gt; &lt;/div&gt;&lt;div id=&quot;footer&quot;&gt; &lt;div class=&quot;wrap&quot;&gt;这里是 footer&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 对wrap设置了固定的宽度，并且设置左右外边距为自动，所以无论浏览器页面大小，wrap始终居中。","tags":[{"name":"html简介","slug":"html简介","permalink":"http://yoursite.com/tags/html简介/"}]},{"title":"HTML2","date":"2016-06-29T16:00:00.000Z","path":"2016/06/30/HTML（2）/","text":"样式有几种引入方式? link和 @import有什么区别?样式引入方式：123456789101112//外部样式表&lt;head&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;index.css&quot;&gt;&lt;/head&gt;//内部样式表&lt;style type=&quot;text/css&quot;&gt; p&#123; color:red; &#125;&lt;/style&gt;//内联样式&lt;p style=&quot;color:red;&quot;&gt;测试&lt;/p&gt; 两种都是外部引用CSS的方式，差别在：1.link是XHTML标签，除了引用CSS外还可以定义rel链接属性等，而@import是CSS提供的一种方式，只能引用CSS。2.link引用CSS时，会在页面载入同时加载，而@import则会在页面完全载入完毕再加载。3.link是CSS2.1提出的，老版本的浏览器会有兼容问题。4.当用JavaScript改变DOM样式时，只有link支持。 文件路径../main.css、./main.css、main.css有什么区别？../main.css：在目录上一级寻找main.css。./main.css,main.css：在当前目录下寻找main.css。 console.log是做什么用的？console.log主要是用来调试JavaScript用的。可以看到对象中的内容，并且不会弹出窗口打断操作。 text-align有几个值，分别有什么作用？12345text-align:left;//文本左对齐text-align:right;//文本右对齐text-align:center;//文本居中text-align:justify;//文本两端对齐text-align:inherit;//从父元素继承文本属性的值 px、em、rem分别是什么？有什么区别？如何使用？px：固定大小像素；em：相对于父元素的像素大小，如果父元素没有设置则逐级向上查找；rem：相对于根节点&lt;html&gt;的像素大小。 对chrome 审查元素的功能做个简单的截图介绍 如下代码，设置 p为几 rem，让h1和p的字体大小相等?12345678910111213&lt;h1&gt;饥人谷&lt;/h1&gt;&lt;p&gt;饥人谷&lt;/p&gt;&lt;style&gt; html&#123; font-size: 62.5%; &#125; p&#123; font-size: 6rem; &#125; h1&#123; font-size: 60px; &#125;&lt;/style&gt; 浏览器的默认字体大小为16px,而根节点&lt;html&gt;的font-size设置为62.5%，所以&lt;html&gt;字体大小为10px,所以应设为6rem。","tags":[{"name":"html简介","slug":"html简介","permalink":"http://yoursite.com/tags/html简介/"}]},{"title":"HTML1","date":"2016-06-28T16:00:00.000Z","path":"2016/06/29/HTML（1）/","text":"网页乱码的问题是如何产生的？怎样解决有多种编码方式，如美国标准信息交换代码ASCII,以及为了将绝大多数语音用一种统一编码方式的UNICODE和万国码UTF-8，和中国自己制定的规则GBK 。而当我们在保存自己编写的HTML文件时会自主选择一种编码方式保存(如GBK)，而当浏览器在打开网页时它并不知道这个文件的编码方式，于是会默认选择一种编码方式打开文件，而当这种默认方式和保存文件时的编码方式不统一时则有可能会造成乱码。要解决乱码要清楚以那种方式保存，并添加相应声明。例：1.当以UTF-8保存时，则在HTML的&lt;head&gt;中添加：&lt;meta charset=&quot;utf-8&quot;&gt;2.当以GBK保存时，则在HTML的&lt;head&gt;中添加：&lt;meta charset=&quot;gbk&quot;&gt; 颜色有几种写法， 红色、 绿色、蓝色、白色、黑色如何表示？ 透明黑色如何表示？#ccc的颜色， #eee的颜色？ #333的颜色？颜色的写法：1.以英文单词表示，如black;2.以16进制表示，如#ffffff；3.以RGB表示，如rgb(0,0,0)； 颜色 英文单词表示 十六进制表示 RGB表示 红色 Red #ff0000 rgb(255,0,0) 绿色 Green #008000 rgb(0,255,0) 蓝色 Blue #0000ff rgb(0,0,255) 白色 White #ffffff rgb(255,255,255) 黑色 Black #000000 rgb(0,0,0) 透明黑色：rgba(0,0,0,0.5);颜色：#ccc:灰色,#eee:浅灰，#333：深灰; &lt;!doctype html&gt;的作用是什么Web 世界中存在许多不同的文档。只有了解文档的类型，浏览器才能正确地显示文档。HTML 也有多个不同的版本，只有完全明白页面中使用的确切 HTML 版本，浏览器才能完全正确地显示出 HTML 页面。这就是 &lt;!DOCTYPE&gt; 的用处。&lt;!DOCTYPE&gt; 不是 HTML 标签。它为浏览器提供一项信息（声明），即 HTML 是用什么版本编写的。而&lt;!doctype html&gt;则是W3C规定的html5文档类型。 严格模式和混杂模式指什么严格模式是浏览器根据web标准去解析页面，是一种要求严格的DTD，不允许使用任何表现层的语法，如&lt;br/&gt;。混杂模式就是浏览器为了兼容很早之前针对旧版本浏览器设计、并未严格遵循 W3C 标准的网页而产生的一种页面渲染模式。 meta有什么作用，常见的值有哪些&lt;meta&gt; 标签规定页面的描述、关键词、文档的作者、最后修改时间的元数据,元数据可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 web 服务。meta标签属性分别是http-equiv属性、name属性、charset属性、content属性。 有什么作用这样写可以达到的效果是如果安装了GCF，则使用GCF来渲染页面，如果未安装GCF，则使用最高版本的IE内核进行渲染。GCF：Google Chrome Frame ，用于给 IE 带来 Chrome 的 open web 技巧以及快速的 JavaScript 引擎。 常见的浏览器有哪些，什么内核IE浏览器：Trident内核Firefox浏览器：Gecko内核Opera浏览器：Blink内核Chrome，Safari浏览器：Webkit内核","tags":[{"name":"html简介","slug":"html简介","permalink":"http://yoursite.com/tags/html简介/"}]}]